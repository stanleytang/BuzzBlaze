a:4:{s:5:"child";a:1:{s:0:"";a:1:{s:3:"rss";a:1:{i:0;a:6:{s:4:"data";s:3:"


";s:7:"attribs";a:1:{s:0:"";a:1:{s:7:"version";s:3:"2.0";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";s:5:"child";a:1:{s:0:"";a:1:{s:7:"channel";a:1:{i:0;a:6:{s:4:"data";s:50:"
	
	
	
	
	
	
	
	
	
		
		
		
		
		
		
		
		
		
		
	";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";s:5:"child";a:4:{s:0:"";a:7:{s:5:"title";a:1:{i:0;a:5:{s:4:"data";s:14:"Pádraic Brady";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"link";a:1:{i:0;a:5:{s:4:"data";s:28:"http://blog.astrumfutura.com";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:11:"description";a:1:{i:0;a:5:{s:4:"data";s:41:"PHP, Zend Framework and Other Crazy Stuff";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:13:"lastBuildDate";a:1:{i:0;a:5:{s:4:"data";s:31:"Wed, 20 Oct 2010 20:57:26 +0000";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"language";a:1:{i:0;a:5:{s:4:"data";s:2:"en";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:9:"generator";a:1:{i:0;a:5:{s:4:"data";s:29:"http://wordpress.org/?v=3.0.1";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"item";a:10:{i:0;a:6:{s:4:"data";s:59:"
		
		
		
		
		
				
		
		
		
		
		
		

		
		
			
			
		
		";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";s:5:"child";a:5:{s:0:"";a:7:{s:5:"title";a:1:{i:0;a:5:{s:4:"data";s:88:"Nanosecond Scale Remote Timing Attacks On PHP Applications: Time To Take Them Seriously?";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"link";a:1:{i:0;a:5:{s:4:"data";s:124:"http://blog.astrumfutura.com/2010/10/nanosecond-scale-remote-timing-attacks-on-php-applications-time-to-take-them-seriously/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:133:"http://blog.astrumfutura.com/2010/10/nanosecond-scale-remote-timing-attacks-on-php-applications-time-to-take-them-seriously/#comments";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:7:"pubDate";a:1:{i:0;a:5:{s:4:"data";s:31:"Wed, 20 Oct 2010 15:48:56 +0000";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"category";a:7:{i:0;a:5:{s:4:"data";s:11:"PHP General";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:1;a:5:{s:4:"data";s:12:"PHP Security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:2;a:5:{s:4:"data";s:14:"Zend Framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:3;a:5:{s:4:"data";s:20:"application security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:4;a:5:{s:4:"data";s:3:"php";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:5;a:5:{s:4:"data";s:12:"php security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:6;a:5:{s:4:"data";s:13:"timing attack";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"guid";a:1:{i:0;a:5:{s:4:"data";s:35:"http://blog.astrumfutura.com/?p=427";s:7:"attribs";a:1:{s:0:"";a:1:{s:11:"isPermaLink";s:5:"false";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:11:"description";a:1:{i:0;a:5:{s:4:"data";s:343:"This article concerns the concept of a Timing Attack (described below) performed remotely over the internet or a local area network. Specifically, it addresses Remote Timing Attacks based on timing differences from a few microseconds to as little as 1 nanosecond (one billionth of a second), a timescale which has been assumed to be impossible";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:32:"http://purl.org/dc/elements/1.1/";a:1:{s:7:"creator";a:1:{i:0;a:5:{s:4:"data";s:7:"padraic";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:40:"http://purl.org/rss/1.0/modules/content/";a:1:{s:7:"encoded";a:1:{i:0;a:5:{s:4:"data";s:40573:"<div class="tweetmeme_button" style="float: right; margin-left: 10px;">
			<a href="http://api.tweetmeme.com/share?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F10%2Fnanosecond-scale-remote-timing-attacks-on-php-applications-time-to-take-them-seriously%2F"><br />
				<img src="http://api.tweetmeme.com/imagebutton.gif?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F10%2Fnanosecond-scale-remote-timing-attacks-on-php-applications-time-to-take-them-seriously%2F&amp;source=padraicb&amp;style=normal&amp;service=bit.ly&amp;service_api=padraic%3AR_94101570b7e190f3de921bc15bb9438d&amp;hashtags=application+security,php,php+security,timing+attack&amp;o=http%3A%2F%2Fblog.astrumfutura.com%2Ffeeds%2Findex.rss2&amp;b=2" height="61" width="50" /><br />
			</a>
		</div>
<p><img class="alignleft" src="http://farm3.static.flickr.com/2267/2262788821_fd31aba3af.jpg" alt="Clock by thecaucus" width="207" height="152" />This article concerns the concept of a Timing Attack (described below) performed remotely over the internet or a local area network. Specifically, it addresses Remote Timing Attacks based on timing differences from a few microseconds to as little as 1 nanosecond (one billionth of a second), a timescale which has been assumed to be impossible to detect over the internet due to the interference of &#8220;network jitter&#8221;. In the article, I will be summarising some of the recent developments in the area with the goal of demonstrating that a dependence on network jitter as a defence is not sustainable and that PHP applications need to come to terms with these forms of attacks while they are still in their infancy.</p>
<p>I&#8217;ve been following the progress of Remote Timing Attacks with a lot of interest over the years, during which time there has been an obvious trend in improving the technique. The most recent reported cases of Remote Timing Attack vulnerabilities, for example, were against the OpenID and OAuth protocols when it was reported in July 2010 that numerous open source implementations of these protocols did not prevent the disclosure of timing information that could enable a Remote Timing Attack. It is important to note that, as with many potential attacks, the protocols themselves contain no vulnerability. This is strictly a potential vulnerability contingent on the method of implementation.</p>
<p><span id="more-427"></span></p>
<h2>What is a Timing Attack?</h2>
<p>A Timing Attack is a form of Side Channel Attack which allows an attacker to discover some secret input to an operation by measuring the operation&#8217;s execution time often based on a set of attacker derived inputs. It&#8217;s a side channel attack because it utilises non-invasive observations which don&#8217;t involve altering the victim application. Other forms of side channel attacks can rely on phenomena such as sound, electromagnetic emissions, power consumption and even temperature. For a Remote Timing Attack, the non invasive observation often targets response time differentials.</p>
<p>A simple example, quite relevant to web applications, is that of <a href="http://www2007.org/papers/paper555.pdf">someone attempting to compile a list of valid usernames recognised by a web application</a>. This is a pointless exercise against many websites where usernames are often public by design (usually to enable social interaction) but there are web applications being designed where usernames are a form of sensitive data not intended for public disclosure. It has long been noted by programmers that, where usernames are not explicitly public by design, disclosing usernames indirectly is a problem. If nothing else it increases the risk of cross referencing username/password combinations from other more seriously compromised websites. We all use a different password for every single site, don&#8217;t we?</p>
<p>At first look, this seems like an impossible task but in reality it doesn&#8217;t take much thinking to realise how many web applications likely treat existing and non-existing usernames differently during a login attempt. Differing treatment may lead to clues about the validity of any username in a few ways:</p>
<ol>
<li>The website might reveal that the username does/does not exist via an error message or more subtle response elements (e.g. slight markup differences).</li>
<li>The client might be redirected to different URLs depending on whether the username exists or not.</li>
<li>An attacker might measure the response time difference between processing a login with an invalid username versus one with a known valid username.</li>
</ol>
<p>Timing Attacks refer to the third option. Over time, many sites have figured out enough not to give away obvious clues about username existence but they still often neglect to hide the impact of the login checks performed by the server. If the login processing time of an existing user is measurably different than that for a non-existing user (bearing in mind the password is wrong for both), the additional delay imposed before sending a response back to a nefarious individual may be so noticeable that it can be reliably distinguished, over many attempts, from the normal background internet jitter. In this way, anyone could compile/validate a list of existing usernames for a web application using dictionaries of known usernames.</p>
<p>One simple step that is not uncommon is to log attempts to authenticate with a bad password. This audit log step might be skipped for non-existing usernames. Immediately we have one timing difference due to the differing treatment between usernames that do exist and those that don&#8217;t. In this case, a simple optimisation introduced the flaw. This alone, or in combination with other operations, is all it might take to giveaway clues about a username&#8217;s state based on the leaked execution time information.</p>
<p>These forms of attack are not restricted to logins. There are countless pieces of information we can deduce simply by paying attention to timing differences in the branching logic of applications. Some more examples. How about a Forgotten Password page? Applications may send these emails within the same process serving a request thus leaking an obvious timing difference when a valid email is used &#8211; asynchronous processing is neglected often enough. Or how about an application where certain resources are only available after login thus leaking timing/availability information indicating whether a user is currently logged in or not? This might seem an innocent leak but since resource requests from a browser are not constrained to any one domain, an attacker can apply a Cross-Site Timing attack against visitors to a web page using Javascript timers (using onload/onerror/etc.) to profile where visitors are currently logged in. In the case of web pages included in a frame/iframe this can, however, <a href="https://developer.mozilla.org/en/The_X-FRAME-OPTIONS_response_header">be prevented with the X-Frame-Options header supported by modern browsers</a> though adoption of this protection will take time. One can feasibly develop this further as a highly selective (as opposed to an easier to detect all or nothing spam approach) attack using other Yes/No timing determinations to narrow the field of victims and utilising attack vectors like Cross-Site Request Forgery (CSRF).</p>
<p>The important tool in everything I&#8217;ve mentioned so far is the ability to reliably measure small timing differences despite the interference of network jitter and other environmental factors (the natural and oft quoted defences against Remote Timing Attacks). Rudimentary statistical analysis is often sufficient to reduce this background noise for noticeably large differences that require few samples to differentiate, and over the years the resolution at which these timing differences can be measured over even the internet has been improving. The more the methods used improve, the smaller the timing difference that can be detected even with network jitter. For attackers where network jitter is too much to handle, there <a href="http://dev.mysql.com/doc/refman/5.1/en/miscellaneous-functions.html#function_sleep">are other ways</a> to game the application&#8217;s timing differences conditionally using SQL Injections if available.</p>
<h2>Those Who Do Not Learn From History&#8230;</h2>
<p>The simple examples above, which are real and known security threats, are an easy way to introduce the topic of Remote Timing Attacks at the macro level. It&#8217;s at this level that we&#8217;re dealing with databases, interacting with web APIs, writing files to disk, engaging in battle with laboriously constructed piles of poorly performing code, and doing all the other stuff we bother measuring with xhprof or xdebug when building web applications. We&#8217;re all familiar with the level of time measurement these require since we actively try to optimise these since they, almost by definition, noticeable. At this level, execution times can differ so substantially that even network jitter can&#8217;t hide it from simpler forms of analysis.<br />
But what about the little things? What about operations that are completed in far shorter timeframes ranging from a few microseconds down to the nanosecond (ns) range?</p>
<p>First, let&#8217;s be clear that even tiny differences of as little as 1ns are useful to attackers. Of course they are! Any indirect leak of information concerning a suitably sensitive operation is a &#8220;leak&#8221;. Whether it leaks something worth the trouble of an attacker to attempt detecting it is another question, but it has been proven beyond any doubt that timing information leaks can be serious security vulnerabilities. Whether they are exploitable over the internet is something we&#8217;ll discuss shortly but first, let&#8217;s look at an example of a tiny timing information leak that could be useful to attackers.</p>
<p>In the C language there is a commonly used function called memcmp() which is used to compare two buffers (strings in PHP terms), returning zero if they are equal or a non-zero value if not. As you would expect, PHP string comparisons using &#8220;==&#8221; will resolve to similar C function calls &#8211; the same is true of every programming language built on C (with varying overheads). What you might not know (unless a C developer &#8211; and I barely qualify <img src='http://blog.astrumfutura.com/wp-includes/images/smilies/icon_wink.gif' alt=';)' class='wp-smiley' /> ) is that memcmp() is typically optimised to return a non-zero value at the first sign of any inequality between the strings being compared. It will not process the entire string needlessly. Depending on compiler optimisations, this comparison will often be done on a byte by byte basis or an optimised 32/64bit basis that may still attempt to locate the errant byte (i.e. it still operates at the level of single bytes even if not apparent at face value).</p>
<p>This means that memcmp() leaks timing information: the more correct one string is compared to another (starting sequentially from the first byte), the more byte comparisons/locations memcmp() must perform, and the longer it takes memcmp() to return a result. An attacker can use the timing differential to judge the correctness of their guesses.</p>
<p>An attacker can take advantage of this in a somewhat obvious way. Assuming memcmp() compares byte by byte, we know that a byte only has 256 possible values. So, if we can reliably tell when memcmp() takes slightly longer to complete, we can figure out one by one the correct byte sequence matching an otherwise unknown comparison string (the secret an attacker is attempting to discover). Starting from the first byte, we just try each of the 256 possible byte values, note which took one caused memcmp() to take longer to complete (once memcmp() knows it&#8217;s correct it will move on to compare the next byte thus needing more time), and rinse and repeat for the rest of the buffer length. In this way, the leaked timing information allows us to figure out the exact content of the secret string we&#8217;re being compared against.</p>
<p>Of course, this has immense value. Instead of having to guess the entire string all at once which would be computationally challenging for any long random string, we now only need to setup an iterative process based on guessing the string byte by byte using very simple steps of 256 possible byte values. In fact, 256 attempts on a single byte turns out to only take 128 guesses on average! This is far from computationally challenging. A 64 byte string would only require, on average, 8,192 guesses (64 x 128).</p>
<p>As hinted at earlier, this isn&#8217;t always feasible. memcmp() can be optimised in a few ways depending on the OS, CPU, compiler and compiler options we use. If, for example, memcmp() was optimised not to compare single bytes but a larger block size of say 32 or 64 bits, our 256 possible attempts would swell towards a computationally challenging number of possibilities since our increment size is now huge. This assumes the memcmp() implementation in question does not attempt to locate errant bytes (which leaks timing information regardless). Since my C knowledge is limited (I merely dabble for the sake of PHP extensions), <a href="http://rdist.root.org/2010/08/05/optimized-memcmp-leaks-useful-timing-differences/">here&#8217;s the techno-babble comparing different operating systems and versions</a>.</p>
<p>Two simple examples where guessing an unknown string would have value to an attacker? Granted, you probably already predicted the first one! Which may <a href="http://beta.ivancover.com/wiki/index.php/Xbox_360_Timing_Attack">be different from everyone else&#8217;s if you own an Xbox 360</a>.</p>
<p>The first is obvious &#8211; let&#8217;s assume the existence of a particularly naïve web application where, during the login process, the inputted password is directly compared against a database stored plaintext password using &#8220;==&#8221; (this may also hold true in comparisons performed by the database itself). With the omission of one way hashing, this direct comparison means that the application is leaking timing information about the nature of the actual password string, thus allowing an attacker to employ a Remote Timing Attack to figure out the correct password for any account they wish. Using one-way hashing should defeat this because it&#8217;s very hard to work backwards from timing leaks when the attacker derived input keeps changing (hashes to a different digest each time a byte changes in the original plaintext input). Just be wary where hashing is employed but the hash is actually sent directly by a client, e.g. HTTP Digest, since this is equivalent to comparing plaintext passwords except that interception of the plaintext password en route is prevented. You might suspect that my example for hash forcing, HTTP Digest, has some replay protection using a nonce but in practice nonces may be omitted, poorly implemented and/or easily predicted thus robbing naïve implementations of their replay protection.</p>
<p>A second example would be any secure protocol relying on a digital signature such as a HMAC. If the server side compares the HMAC attached to a client message to its own generated HMAC (based on a shared secret) from the message data using &#8220;==&#8221;, we have a similar result. The comparison leaks timing information about how correct the attacker&#8217;s HMAC guess was for a given request. This was the specific issue reported against open source implementations of OpenID and OAuth. Of course, there are mitigating factors &#8211; a well designed protocol would also employ a single-use nonce value to be included in each message to prevent attacker replays (and so preventing Timing Attacks). This nonce is never reused within a reasonable time period, so the signature of any otherwise identical message would always be different due to the variability introduced by the added nonce value.<br />
The problem, as identified with OpenID, is that nonce protection requires that the nonce be checked first as a cause for refusing a request before the server executes the HMAC comparison (otherwise it performs the HMAC comparison and leaks timing information anyway &#8211; good nonce or bad!). The other problem is whether implementations use a reasonably sufficient nonce generation/verification process.</p>
<p>Implementors can be easily confused into thinking a nonce is some form of timestamp which is a mistake, or that nonces are unnecessary complexity which is even worse. Nonces based solely on a timestamp are subject to time &#8211; and time is predictable if you have a good clock. Nonces interpreted as a Session ID (to eliminate storage requirements) are fixed over a specific time frame which, again, makes them predictable. Not implementing nonces at all (or really poorly) means that replay attacks suffer no preventative measure, giving free reign to attackers in intercepting and replaying requests from a client.</p>
<p>These examples are all good, but let&#8217;s look at what kind of timing information is being disclosed to the world by them. Afterall, the examples given are likely to require an attack over the internet (assuming direct LAN or even direct machine access is impractical).</p>
<h2>&#8230;Are Doomed To Repeat It</h2>
<p>What measure of leaked timing information does memcmp() actually give away? It&#8217;s hard to stick a concrete number on it so we&#8217;ll assume it needs 1 nanosecond (ns) on a reasonable CPU to compare any two bytes during its execution. I borrowed this from the Lawson/Taylor talk at Blackhat USA so it&#8217;s as good as any other arbitrary number. If you want to get really conservative, you can bump it up a bit (i.e. making the timing difference more detectable). Concrete numbers are dangerous of course since they will obviously vary depending on hardware, so we really should assume that somewhere it will take longer than 1ns.</p>
<p>Timing Attacks have been demonstrated for years with local access to servers going back as far as 1996 when <a href="http://www.cryptography.com/public/pdf/TimingAttacks.pdf">Paul C. Kocher wrote about Timing Attacks against Diffie-Hellman and RSA</a>. When you can directly observe the actual machine doing the work, or even over a minimal network setup, network jitter doesn&#8217;t have much of a chance to interfere. Once you throw in enough network jitter, however, nanosecond/microsecond level timing differences become extremely difficult to measure. So let&#8217;s shift over to the next question of interest. What kind of timing differences can we reliably resolve over the internet?</p>
<p>This is where using &#8220;Timing Attack&#8221; and &#8220;Internet&#8221; in the same sentence seems to border on the insane. We are so used as web developers to having our time measurements bottom out at the microsecond level (not all of us work at Facebook) that we live with the comfortable knowledge that nothing below this is likely to be relevant. So what if we are leaking 1ns clues on string comparisons to the entire world? Network jitter should swallow that up with gusto! Right?</p>
<p>If Timing Attacks at the nanosecond resolution were possible on web applications over the internet, we&#8217;d likely be in serious trouble. It&#8217;s not like memcmp() is the only possible item subject to tiny timing differences depending on inputs. There can be little doubt about this &#8211; it is not an area generally worried about in web application security so there are a lot of applications, libraries and even C extensions/libraries which routinely leak timing information about sensitive operations all the time. Some of them, like OpenSSL, have already been previously patched for Timing Attack vulnerabilities in the past but, despite this awareness, may refuse to patch similar vulnerabilities more suited to remote exploitation. The exploitability of these attacks over the internet is entirely dependent on eliminating the impact of network jitter, and it is this feat that will determine the viability of exploiting unpatched vulnerabilities.</p>
<p>The most recent research was carried out by <a href="http://rdist.root.org/">Nate Lawson and Taylor Nelson of Root Labs</a> and presented at Blackhat USA in July of this year. In the talk, Lawson/Nelson explain that there are a number of factors to consider in figuring out just what kind of detectable resolution for timing information is possible over networks. Broadly speaking there are three essential factors &#8211; a good vantage point and configuration for your client, the capability to gather sufficient samples, and an appropriate method of statistical analysis. While the research was, in my mind, still in its data collection stage, the results were extremely interesting. If you can spare an hour some time, you can <a href="http://www.youtube.com/watch?v=idjDiBtu93Y&amp;feature=related">watch the entire session over on Youtube</a>.</p>
<p>Briefly, to explain the three factors I noted earlier. A good vantage point is helpful in establishing a high quality connection to the target system which minimises unfiltered network jitter. This can depend on a few other factors like ensuring the client system is configured for the task, using high quality connections/infrastructure, and even locating the client closer to the target in a network (where it makes a difference &#8211; less network hops doesn&#8217;t necessarily lessen network jitter). These, among other factors, can assist in minimising network jitter and improving the resolution at which which timing differences can be detected. Gathering sufficient samples is obvious &#8211; the greater the number of samples, the more accurately timing differences can be distinguished from the largely additive background noise and the more resolution you can theoretically obtain. An appropriate method of analysis relies on the field of statistics. Unsurprisingly, statistical analysis is capable of picking out outrageously tiny signals from all the noise in sampled data once you use an appropriate approach.</p>
<p>Considering this, here&#8217;s the table of results noted from Lawson/Taylor&#8217;s Blackhat USA talk (based on a sample size of 9,000):</p>
<p><code><br />
Localhost: &lt; 25ns<br />
Crossover Cable: &lt; 25ns<br />
LAN: 40ns<br />
Amazon EC2 to EC2: 15 - 400ns<br />
Internet DSL to Amazon EC2: &lt; 20µs</code></p>
<p>Compare this against the last set of numbers I knew about from <a href="http://www.cs.rice.edu/~dwallach/pub/crosby-timing2009.pdf">Crosby et al.&#8217;s Opportunities And Limits Of Remote Timing Attacks</a> which also indicated 20us for the internet and 100ns or less across a LAN. The results at Blackhat USA have improved on this in some areas and pointed out additional results. Further, it reconfirms that the sample sizes needed for these kinds of resolutions are very low. 9,000 samples may seem nuts at first glance but it&#8217;s easily accomplished.</p>
<p>The results show us that detecting timing differences over the internet is limited to a resolution of 20 microseconds (µs) over what we consider typical internet connections. This is based on a sample size of 9,000 requests so we can (and should) assume that a higher sample size would offer an even better resolution. A determined attacker could feasibly resort to millions of measurements depending on the target, perhaps offloaded to a botnet or to innocent clients using, albeit far less reliable, Cross-Site Timing attacks. While we are primarily concerned with the internet here, the results also backup Crosby et al.&#8217;s 100ns measurements over a LAN, improving the resolution to less than 40ns. Lawson/Nelson&#8217;s talk also reported a LAN resolution of &lt;15 nanoseconds (almost a three times improvement over 40ns) using a sample size of 49,000 &#8211; I can&#8217;t emphasise enough the importance of a sufficient sample size. People tend to quote numbers similar to the Lawson/Nelson table as being constant without understanding that the results are entirely sample size dependent.</p>
<p>Considering our memcmp() execution time for comparing two bytes is assumed to be around 1 nanosecond, it&#8217;s obvious that under the internet resolution of 20µs such timing differences are undetectable. This conclusion, while apparently reasonable, is a bit presumptious. What happens with a server that has a slow CPU/limited RAM and is running a slightly more expensive operation than a simple memcmp() byte compare, perhaps on one of those new Intel Atom based SeaMicro SM10000s? Yes, they really do use Intel Atom CPUs. What if we increase the sample size substantially over 10,000? What if we locate a better method of collecting/analysing the resulting data? These questions all suggest that that dismissing Remote Timing Attacks based on one single example is questionable. Of course, 1ns vs 20µs presents a huge gulf to demonstrating the exploitability of such a scenario over an internet connection &#8211; but this does not preclude cases where better appoaches to detecting timing differences and/or the existence of more measurable operations would give rise to a true exploit.</p>
<p>Let&#8217;s back off from the internet though. Network jitter over your basic internet is noisy, too noisy for a 1ns resolution without going through a lot of hoops and waiting for more research or Internet 2.0 to emerge with magical anti-jitter properties. In any case, who cares about a consumer connection over dodgy cables potentially planted in the ground decades ago (unless you&#8217;re Swedish)? This is the 21st Century, and computing has a new 21st Century solution: The Cloud.</p>
<p>If we want to get really clever, let&#8217;s just target someone using Amazon&#8217;s EC2 and leverage off Amazon&#8217;s own superior network. The Lawson/Nelson results contain another interesting data point &#8211; the resolution at which timing differences could be discerned between EC2 instances was between 15ns and 400ns (again based on a 9,000 sample size). We can just filter out samples that are unfortunate enough to hit the 400ns wall (due to some process within the EC2 system that has not been identified…yet) and revel in 15ns resolutions between our EC2 instance and a victim&#8217;s. The key to this is using a really great vantage point &#8211; another EC2 instance located close to, if not on the same hardware as, the victim. Achieving this <a href="http://cseweb.ucsd.edu/~hovav/dist/cloudsec.pdf">is not as far fetched as you might suspect</a> given the security cost of relying on a shared network.</p>
<p>Throw in possible situation improvements (for an attacker) due to CPU/RAM constraints, increased sampling and analysis, and we now have something a heck of a lot more worrying. The real possibility that our network jitter defence is dead in the water &#8211; the gulf between a 1ns memcmp() comparison and a 15ns detection resolution no longer looks insurmountable. It looks downright dangerous if you assume detection can only improve with more samples and other expensive operations that are worth targeting regularly exceed 1ns.</p>
<p>I&#8217;m sure we all love cloud computing regardless but there can be no doubt that pointing fingers at the internet&#8217;s 20µs achievable resolution is near pointless. Especially in the open source world, we don&#8217;t have any control over whether or not our applications and libraries will be hosted in the cloud and therefore we must assume they will be (whether it be EC2, Azure, Mosso and such). Following that logic, this means we must now ensure that any sensitive operations subject to Remote Timing Attacks can stand up to the 15ns detection resolution at 9,000 samples (or whatever it would be with a much better sample size) without leaking information about sensitive operations.</p>
<h2>Removing Timing Differences: What Are Your Options?</h2>
<p>Back in July, Lawson/Nelson reported that many open source implementations of OpenID leaked timing information. The <a href="http://lists.openid.net/pipermail/openid-security/2010-July/thread.html#1156">resulting mailing list thread contains some interesting ideas to resolve this</a>. For the moment, we&#8217;ll ignore network jitter &#8211; a 15ns resolution (less with better sampling) between Amazon EC2 instances just puts paid to that as a plausible defence (not that I doubt it will be argued otherwise forever).</p>
<p>Proposed fixes in the thread included adding random noise (i.e. a random delay before returning responses). Lawson/Nelson&#8217;s Blackhat USA talk addressed this suggestion directly, as have previous studies, showing that random noise achieved nothing other than to require that an attacker take an increased sample size to eliminate it. The random noise route increases the difficulty of an attack but does not obviate the need for a fuller solution.</p>
<p>Another suggestion was that this was not a problem since OpenID also requires non-repeating nonces which means that any message&#8217;s HMAC digital signature (the secret a timing attack might target) should change on every request even though its data was otherwise identical, thus preventing the replay attacks needed to take advantage of guessing the correct HMAC. This was also picked apart, to a degree, by noting that timing information was leaked anyway unless implementations checked the nonce before the digital signature and terminated request verification if an invalid nonce was detected. It turned out that the order of these operations, and this specific treatment, is not specified for OpenID 2.0 and so implementations may or may not actually use the more secure order of checks. Assuming they use secure nonces in the first place given how easily developers can implement them poorly. Another suggested fix was implementing a random start point within each string for performing a string comparison. While it would probably work, it would add complexity and performance issues that might prove needless.</p>
<p>The simplest fix is, for string comparisons at least, simply to ensure that for any two strings being compared, the comparison takes the exact same number of operations (and thus a fixed execution time) no matter what. This eliminates any C compare function&#8217;s optimisation that leaks timing information completely and it&#8217;s a relatively simple function even in PHP. Of course the downside is that this must be implemented in native PHP for now, not C, and therefore it does involve a small performance penalty. As usual, you either pick better performance or better security. Since the performance difference is minimal, I&#8217;d prefer the security.</p>
<p><code><div id="wpshdo_1" class="wp-synhighlighter-outer"><div id="wpshdt_1" class="wp-synhighlighter-expanded"><table border="0" width="100%"><tr><td align="left" width="80%"><a name="#codesyntax_1"></a><a id="wpshat_1" class="wp-synhighlighter-title" href="#codesyntax_1"  onClick="javascript:wpsh_toggleBlock(1)" title="Click to show/hide code block">Source code</a></td><td align="right"><a href="#codesyntax_1" onClick="javascript:wpsh_code(1)" title="Show code only"><img border="0" style="border: 0 none" src="http://blog.astrumfutura.com/wp-content/plugins/wp-synhighlight/themes/default/images/code.png" /></a>&nbsp;<a href="#codesyntax_1" onClick="javascript:wpsh_print(1)" title="Print code"><img border="0" style="border: 0 none" src="http://blog.astrumfutura.com/wp-content/plugins/wp-synhighlight/themes/default/images/printer.png" /></a>&nbsp;<a href="http://blog.astrumfutura.com/wp-content/plugins/wp-synhighlight/About.html" target="_blank" title="Show plugin information"><img border="0" style="border: 0 none" src="http://blog.astrumfutura.com/wp-content/plugins/wp-synhighlight/themes/default/images/info.gif" /></a>&nbsp;</td></tr></table></div><div id="wpshdi_1" class="wp-synhighlighter-inner" style="display: block;"><div class="php" style="font-family:monospace;"><pre class="de1"><span class="kw2">function</span> secure_compare<span class="br0">&#40;</span><span class="re0">$a</span><span class="sy0">,</span> <span class="re0">$b</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><a href="http://www.php.net/strlen"><span class="kw3">strlen</span></a><span class="br0">&#40;</span><span class="re0">$a</span><span class="br0">&#41;</span> <span class="sy0">!==</span> <a href="http://www.php.net/strlen"><span class="kw3">strlen</span></a><span class="br0">&#40;</span><span class="re0">$b</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> <span class="kw4">false</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
    <span class="re0">$result</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="re0">$i</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="re0">$i</span> <span class="sy0">&lt;</span> <a href="http://www.php.net/strlen"><span class="kw3">strlen</span></a><span class="br0">&#40;</span><span class="re0">$a</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="re0">$i</span><span class="sy0">++</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="re0">$result</span> <span class="sy0">|=</span> <a href="http://www.php.net/ord"><span class="kw3">ord</span></a><span class="br0">&#40;</span><span class="re0">$a</span><span class="br0">&#91;</span><span class="re0">$i</span><span class="br0">&#93;</span><span class="br0">&#41;</span> ^ <a href="http://www.php.net/ord"><span class="kw3">ord</span></a><span class="br0">&#40;</span><span class="re0">$b</span><span class="br0">&#91;</span><span class="re0">$i</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="re0">$result</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div></div><br />
</code></p>
<p>The code above is fairly straightforward. It ensures that every single byte of each string parameter is compared in the correct order, with the XOR value of both added to a tracking variable. If, at the end of the process, the tracking variable equals zero then the strings were identical. This method does obviously leak another piece of information &#8211; the function returns quickly if the two strings being compared are not the same length. It&#8217;s a compromise of sorts on the basis that this does not tell an attacker anything other than the expected string length (something they may even know already in the case of a standard protocol where it would be specified).</p>
<p>Outside of string comparison, the strategy is obviously to minimise, if not eliminate, observable timing differences where such differences may disclose sensitive information. Don&#8217;t expect total response time to be the only target. In the case of content chunking (where it applies), inter-chunk timing can help an attacker focus more clearly on a specific subset of the processing being applied for a request. Obviously, eliminating timing differences on everything is ridiculous so focus your efforts. The best targets are those where sensitive information is being used when operating on user sourced data.</p>
<h2>Time To Take This Seriously?</h2>
<p>The prevailing belief is simple: if a timing difference is sufficiently small, it will be impossible to distinguish it from network jitter. As I&#8217;ve examined above, the evidence simply is not supporting this line of reasoning any longer. It&#8217;s a fallacy; it always was a fallacy; and continuing to blindly believe in it is misleading. If we acknowledge that network jitter can be sufficiently filtered out to allow the measurement of very small timing differences then Remote Timing Attacks are no longer impossible.</p>
<p>Over the past year, Remote Timing Attacks have been reported as vulnerabilities and have proven compelling enough to make vendors to issue fixes. <a href="http://rdist.root.org/2009/05/28/timing-attack-in-google-keyczar-library/">Google&#8217;s Keyczar library was fixed during 2009 for a timing attack vulnerability</a>, as was Java SE 6 in <a href="http://java.sun.com/javase/6/webnotes/6u17.html">Update 17</a> though Java remains far more susceptible to timing attacks than PHP due to the poor performance of its comparison methods. While not web applications in and of themselves, these are used within actual web applications against which any attacks would be targeted. Ruby On Rails, something closer to our environment being a web application framework, was also <a href="https://groups.google.com/group/rubyonrails-security/browse_thread/thread/da57f883530352ee">patched for a potential Timing Attack vulnerability</a> in September 2009. In March 2010, CouchDB <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0009">had it&#8217;s own run in with memcmp() like string comparisons as a timing attack vulnerability</a>. More recently, Microsoft is dealing with the same issue <a href="http://threatpost.com/en_us/blogs/workarounds-not-enough-protect-against-aspnet-attacks-092710">after the reporters of the ASP.NET padding oracle vulnerability stated that a Timing Attack would work</a> in place of the easier error message leaks originally removed by a Microsoft workaround to the issue. These are just the tip of a very large iceburg of unfixed timing information leaks.</p>
<p>So yes, perhaps it is time to take this seriously. If there is a problem with Remote Timing Attacks, it&#8217;s one of perception. While the data piles up indicating they are already exploitable, real world exploit and security vulnerability examples are thin on the ground. On the other hand, Timing Attacks without the remote element are far more established so the only actual defence employed in most other cases is hiding behind network jitter. It would be great for a researcher to literally prove a specific exploit as part of a study instead of simply referring to, albeit valuable, the separate parts that make the R in RTA possible. Some people need the tangible proof that a fully proven exploit provides, and others will continue to play down the attack form until this turns up. Such research would be much needed bombshell to provoke more vendors into fixing timing information leaks. Unfortunately, Timing Attacks aren&#8217;t as easy to demonstrate as alert(&#8220;XSS&#8221;) <img src='http://blog.astrumfutura.com/wp-includes/images/smilies/icon_wink.gif' alt=';)' class='wp-smiley' /> . In the meantime, let&#8217;s play it safe and keep Remote Timing Attacks in mind. Where possible, implement the necessary preventative yourself or report it to maintainers if you see this issue in a library or application you use. Forewarned is forearmed.</p>
<p>As of version 1.11 which has <a href="http://framework.zend.com/download/latest">been released as a beta</a>, Zend Framework has been patched to remove several timing leaks primarily as a countermeasure against any future exploitation attempts of this nature. This is not considered a critical security vulnerability in the framework given the paucity of evidence that exploits are actively being pursued. Implementing it now, before exploits are widely in use, is simply an act of prudence that offers a measure of forward looking protection for Zend Framework users. I would encourage other frameworks and libraries to take similar steps. Let&#8217;s nip this in the bud. And, add decent nonce implementations where necessary if we haven&#8217;t already, please <img src='http://blog.astrumfutura.com/wp-includes/images/smilies/icon_wink.gif' alt=';)' class='wp-smiley' /> .</p>
<div class="zemanta-pixie" style="margin-top: 10px; height: 15px;"><a class="zemanta-pixie-a" title="Enhanced by Zemanta" href="http://www.zemanta.com/"><img class="zemanta-pixie-img" style="border: medium none; float: right;" src="http://img.zemanta.com/zemified_e.png?x-id=fae69d31-f29d-4419-aa05-fdf8e11f3cae" alt="Enhanced by Zemanta" /></a></div>
";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:36:"http://wellformedweb.org/CommentAPI/";a:1:{s:10:"commentRss";a:1:{i:0;a:5:{s:4:"data";s:129:"http://blog.astrumfutura.com/2010/10/nanosecond-scale-remote-timing-attacks-on-php-applications-time-to-take-them-seriously/feed/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:38:"http://purl.org/rss/1.0/modules/slash/";a:1:{s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:3:"100";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}}}i:1;a:6:{s:4:"data";s:62:"
		
		
		
		
		
				
		
		
		
		
		
		
		

		
		
			
			
		
		";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";s:5:"child";a:5:{s:0:"";a:7:{s:5:"title";a:1:{i:0;a:5:{s:4:"data";s:54:"Do Cryptographic Signatures Beat SSL/TLS In OAuth 2.0?";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"link";a:1:{i:0;a:5:{s:4:"data";s:90:"http://blog.astrumfutura.com/2010/10/do-cryptographic-signatures-beat-ssltls-in-oauth-2-0/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:99:"http://blog.astrumfutura.com/2010/10/do-cryptographic-signatures-beat-ssltls-in-oauth-2-0/#comments";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:7:"pubDate";a:1:{i:0;a:5:{s:4:"data";s:31:"Fri, 08 Oct 2010 17:41:00 +0000";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"category";a:8:{i:0;a:5:{s:4:"data";s:11:"PHP General";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:1;a:5:{s:4:"data";s:12:"PHP Security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:2;a:5:{s:4:"data";s:14:"Zend Framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:3;a:5:{s:4:"data";s:5:"oauth";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:4;a:5:{s:4:"data";s:11:"php general";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:5;a:5:{s:4:"data";s:12:"php security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:6;a:5:{s:4:"data";s:12:"pubsubhubbub";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:7;a:5:{s:4:"data";s:14:"zend framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"guid";a:1:{i:0;a:5:{s:4:"data";s:35:"http://blog.astrumfutura.com/?p=425";s:7:"attribs";a:1:{s:0:"";a:1:{s:11:"isPermaLink";s:5:"false";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:11:"description";a:1:{i:0;a:5:{s:4:"data";s:332:"This post is more about perception vs reality than anything else. When it comes to application security, we like to consider that the steps we take to protect ourselves are unassailable bastions interlocked to poke sharp things at incoming attackers. What we don&#8217;t like is knowing that our bastions are always at risk of being";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:32:"http://purl.org/dc/elements/1.1/";a:1:{s:7:"creator";a:1:{i:0;a:5:{s:4:"data";s:14:"Pádraic Brady";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:40:"http://purl.org/rss/1.0/modules/content/";a:1:{s:7:"encoded";a:1:{i:0;a:5:{s:4:"data";s:7830:"<div class="tweetmeme_button" style="float: right; margin-left: 10px;">
			<a href="http://api.tweetmeme.com/share?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F10%2Fdo-cryptographic-signatures-beat-ssltls-in-oauth-2-0%2F"><br />
				<img src="http://api.tweetmeme.com/imagebutton.gif?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F10%2Fdo-cryptographic-signatures-beat-ssltls-in-oauth-2-0%2F&amp;source=padraicb&amp;style=normal&amp;service=bit.ly&amp;service_api=padraic%3AR_94101570b7e190f3de921bc15bb9438d&amp;hashtags=oauth,php+general,php+security,pubsubhubbub,zend+framework&amp;o=http%3A%2F%2Fblog.astrumfutura.com%2Ffeeds%2Findex.rss2&amp;b=2" height="61" width="50" /><br />
			</a>
		</div>
<p>This post is more about perception vs reality than anything else. When it comes to application security, we like to consider that the steps we take to protect ourselves are unassailable bastions interlocked to poke sharp things at incoming attackers. What we don&#8217;t like is knowing that our bastions are always at risk of being undermined in numerous unexpected ways. The consistent reaction among programmers is the same &#8211; we often pretend those bastions are completely unassailable no matter what and using any excuse necessary. Reality isn&#8217;t always a factor in my experience.</p>
<p>OAuth 2.0 is the next version of OAuth. It&#8217;s always great to see a good thing get better but the new version started off with an oddity inherited from OAuth WRAP. It removed the requirement for cryptographic signatures. Anyone who has skirmished with OAuth 1.0 has probably found the signature requirement a PITA. It&#8217;s poorly specified, subject to language specific errors, and difficult to debug. OAuth 2.0 would do away with this for these same reasons, replacing the need for digital signatures with a requirement that OAuth 2.0 operate over SSL/TLS between web servers. In this way, requests could not be intercepted by a Man-In-The-Middle (MITM), altered or replayed, thus rendering the need for digital signing obsolete. Simple as pie.</p>
<p>Very recently, a similar proposal was raised in relation to Pubsubhubbub which needs optional cryptographic signatures to prevent potential vulnerabilities in scenarios where topic updates must be verified as coming from a trusted source. The new Pubsubhubbub measure would have dropped any need for an all-encompassing cryptographic signature of both the topic body and its headers (currently headers are not signed which is problematic for future use) in favour of requiring SSL/TLS support on both sides (i.e. both Hubs and Subscribers). This was inspired by the bearer token approach of OAuth 2.0 over TLS currently required when using OAuth 2.0 from web servers. Technically it&#8217;s a simple effective solution.</p>
<p>However, both of these have the same problem. SSL/TLS offers a perception of unassailable security at odds with reality. The reality is harsh. SSL/TLS from a browser is, for most purposes, rock solid. Your connections are secure and if Firefox stumbles over a SSL Certificate it can&#8217;t validate or doesn&#8217;t immediately trust, it warns you, giving you the option of allowing an exception. This all works because we don&#8217;t each build our own browser from the ground up. The narrow field and expertise dedicated to each ensures SSL/TLS works as it should. Let&#8217;s turn that view on web applications sitting on a web server. Here we find more than a couple of discouraging trends.</p>
<p>The first is that setting up SSL/TLS is, for at least some percentage of people, difficult. Servers are misconfigured, SSL certificates are reused on different domains, and SSL certificates vary between self-signed and those signed by a trusted party which needs to be paid. It&#8217;s a bit on the messy side and mistakes are common. This was one reason why I objected to the Pubsubhubbub proposal &#8211; Subscribers refer to anyone wishing to receive topic updates, which is, well, everyone. The chances of everyone being able, or even capable, of setting up SSL/TLS for their websites is small.</p>
<p>The second is that client libraries for HTTP may be subject to insecure behaviour. The simplest example here is PHP itself, where the <a href="http://php.net/manual/en/context.ssl.php">default options for the SSL context</a> sets the verify_peer option to FALSE. If one were to build any SSL/TLS based protocol implementation in PHP without realising this (which people do), they will of course fail to verify SSL certificates encountered by their client. On the other hand, curl has SSL peer verification enabled by default. Insecurity by default is a nightmare.</p>
<p>The third, related to how hard/error prone it is for people to get SSL setup right, is the all too common practice of dealing with SSL certificate problems by deliberately disabling SSL Certificate verification in client libraries. Great for testing, bad for production purposes. This practice is widespread to ensure HTTPS requests will still work regardless of the state of the SSL certificate employed by the server. Sure, you&#8217;ll get a valid error-free response &#8211; but from who?</p>
<p>These three issues combine to offer a picture where SSL/TLS can be significantly broken on the web. This is hardly news. So hearing about SSL/TLS requirements in commonly used protocols begs the simple question: how does it improve security when it obviously conflicts with commonplace practice? </p>
<p>This is why protocols such as OAuth 2.0 and Pubsubhubbub need to tread carefully. Mandating the use of SSL/TLS introduces a single point of failure that will fail. It&#8217;s guaranteed to fail. It&#8217;s already failing. For those left vulnerable by such failures from, for example, an open source library that reaches common use, <a href="http://www.sans.org/reading_room/whitepapers/threats/ssl-man-in-the-middle-attacks_480">an attacker can just walk right in with a Man-In-The-Middle (MITM) attack</a>. Sure, you&#8217;re using HTTPS, but if you&#8217;re not verifying certificates you do not have any guarantee that you are communicating with the intended trusted server.</p>
<p>Compare this to digital signatures. You have a shared secret that is not known to any potential MITM. You have a signature to verify the origin of any request/response. You have a random non-repeating nonce which varies the signature to prevent both replay attacks and remote timing attacks. You can additionally run it over SSL/TLS all you want, secure in the knowledge that John Doe&#8217;s PHP Streams based HTTP client will always work securely even if SSL certificate verification is still disabled by default. And best of all? You can&#8217;t optionally disable it! Either you implement it, or nothing will work.</p>
<p>Like practically everything in security, it’s a choice. Secure the protocol in depth, or make it easier to implement. You can&#8217;t have both which is why protocols will always be a PITA to implement when designed with security uppermost in their list of important features. It can&#8217;t be helped.</p>
<p>Back to OAuth 2.0, it has been mentioned that the next draft will contain an option to use cryptographic signatures instead of relying solely on SSL/TLS. This is a significant improvement in my opinion, and gives implementers back the ability to freely choose the most appropriate form of security for their APIs. You can all thank <a href="http://hueniverse.com/2010/09/oauth-2-0-without-signatures-is-bad-for-the-web/">Erin Hammer-Lahav for triggering this</a> or, you know, curse him forever when it becomes the standard means of using OAuth 2.0 from a web server and you are faced with implementing it <img src='http://blog.astrumfutura.com/wp-includes/images/smilies/icon_wink.gif' alt=';)' class='wp-smiley' /> .</p>
";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:36:"http://wellformedweb.org/CommentAPI/";a:1:{s:10:"commentRss";a:1:{i:0;a:5:{s:4:"data";s:95:"http://blog.astrumfutura.com/2010/10/do-cryptographic-signatures-beat-ssltls-in-oauth-2-0/feed/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:38:"http://purl.org/rss/1.0/modules/slash/";a:1:{s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:2:"26";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}}}i:2;a:6:{s:4:"data";s:56:"
		
		
		
		
		
				
		
		
		
		
		

		
		
			
			
		
		";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";s:5:"child";a:5:{s:0:"";a:7:{s:5:"title";a:1:{i:0;a:5:{s:4:"data";s:73:"Contributing To Zend Framework 2.0 Is Free! Hurry Before This Offer Ends!";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"link";a:1:{i:0;a:5:{s:4:"data";s:109:"http://blog.astrumfutura.com/2010/09/contributing-to-zend-framework-2-0-is-free-hurry-before-this-offer-ends/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:118:"http://blog.astrumfutura.com/2010/09/contributing-to-zend-framework-2-0-is-free-hurry-before-this-offer-ends/#comments";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:7:"pubDate";a:1:{i:0;a:5:{s:4:"data";s:31:"Mon, 20 Sep 2010 17:28:00 +0000";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"category";a:6:{i:0;a:5:{s:4:"data";s:11:"PHP General";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:1;a:5:{s:4:"data";s:12:"PHP Security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:2;a:5:{s:4:"data";s:14:"Zend Framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:3;a:5:{s:4:"data";s:11:"php general";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:4;a:5:{s:4:"data";s:12:"php security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:5;a:5:{s:4:"data";s:14:"zend framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"guid";a:1:{i:0;a:5:{s:4:"data";s:35:"http://blog.astrumfutura.com/?p=424";s:7:"attribs";a:1:{s:0:"";a:1:{s:11:"isPermaLink";s:5:"false";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:11:"description";a:1:{i:0;a:5:{s:4:"data";s:281:"Are you feeling idle these days? Do you have a deep gnawing feeling to do something before you go nuts? Playing the same old maps in Modern Warfare 2 night in and night out deperately trying to keep boredom at bay? Then today we have great news, because for the low low price of $0";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:32:"http://purl.org/dc/elements/1.1/";a:1:{s:7:"creator";a:1:{i:0;a:5:{s:4:"data";s:14:"Pádraic Brady";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:40:"http://purl.org/rss/1.0/modules/content/";a:1:{s:7:"encoded";a:1:{i:0;a:5:{s:4:"data";s:4097:"<div class="tweetmeme_button" style="float: right; margin-left: 10px;">
			<a href="http://api.tweetmeme.com/share?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F09%2Fcontributing-to-zend-framework-2-0-is-free-hurry-before-this-offer-ends%2F"><br />
				<img src="http://api.tweetmeme.com/imagebutton.gif?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F09%2Fcontributing-to-zend-framework-2-0-is-free-hurry-before-this-offer-ends%2F&amp;source=padraicb&amp;style=normal&amp;service=bit.ly&amp;service_api=padraic%3AR_94101570b7e190f3de921bc15bb9438d&amp;hashtags=php+general,php+security,zend+framework&amp;o=http%3A%2F%2Fblog.astrumfutura.com%2Ffeeds%2Findex.rss2&amp;b=2" height="61" width="50" /><br />
			</a>
		</div>
<p>Are you feeling idle these days? Do you have a deep gnawing feeling to do something before you go nuts? Playing the same old maps in Modern Warfare 2 night in and night out deperately trying to keep boredom at bay? Then today we have great news, because for the low low price of $0 (excl. ISP charges) you are invited to spend some of your free time contributing to Zend Framework 2.0. That&#8217;s right! It&#8217;s free! We&#8217;ll even throw in free access to Github.com and a free <a href="http://framework.zend.com/wiki/display/ZFDEV2/Zend+Framework+Git+Guide">Getting Started With Git Guide</a>!</p>
<p>What do you get for this ultra low price? Action! Excitement! Drama! Witness the birth of the fastest framework in PHP (<a href="http://blog.astrumfutura.com/archives/421-PHP-Framework-Benchmarks-Entertaining-But-Ultimately-Useless.html">or your money back</a>). Better still, help it through its birthing pains today and lay claim to ego inflating bragging rights for years to come. They look good on a T-Shirt, office plaque or the next edition of your Curriculum Vitae or Resume.</p>
<p>Zend Framework 2.0 recently passed Milestone 1 on <a href="http://framework.zend.com/wiki/display/ZFDEV2/Zend+Framework+2.0+Milestones">its development track</a> and is rocking on PHP 5.3 in all its namespaced glory. Milestone 2 is the introduction of <a href="http://framework.zend.com/wiki/display/ZFDEV2/Proposal+for+Exceptions+in+ZF2">the new Exception regime</a> to ensure all of the frameworks&#8217; fun components throw Exceptions that are specific enough to be useful.</p>
<p>Why waste your idleness on the Devil&#8217;s work when you can be bringing salvation to armies of PHP programmers? Look up the <a href="http://framework.zend.com/wiki/display/ZFDEV2/Milestone+Exceptions">List of Who&#8217;s Doing Which Component&#8217;s Exception Overhaul (or, The WDWCEO List for short)</a>. If a component is not listed, ask on the mailing lists if you can perform its Exception overhaul, and get cracking. It&#8217;ll tide you over until Activision&#8217;s next overpriced MW2 map pack or until Respawn announce details of their MW2 killer.</p>
<p>If you still have idle time, we are accepting new proposals for Zend Framework 2.0 (or maybe there&#8217;s a ZF 1.0 proposal you should consider updating to ZF 2.0?). There are tons of ZF 1.0 Zend_Service components that need to be migrated entirely to PHP 5.3 namespaced code for ZF 2.0.</p>
<p>The tasks are there. Where are you?</p>
<p>Perhaps you want to work on something component related? Want to know what everyone else has their fingers in so you can see which components are without maintainers or might like an extra pair of hands and some spare toes? Checkout the <a href="http://framework.zend.com/wiki/display/ZFDEV2/Component+Maintainers">Components and Maintainers List for ZF 2.0</a>.</p>
<p>So whip out your credit card, realise you get to do this for absolutely no cost (excl. ISP charges), put the credit card back in your wallet, and visit all the URLs contained above to get started. If you wish to speak to a Zend Framework customer representative visit the #zftalk.dev channel on Freenode.net and shout &#8220;I wanna contribute, dammit!&#8221;. Remember to specify that your age is above five years.</p>
<p>This is a time limited offer which ends when Hell freezes over. Better hurry up!</p>
";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:36:"http://wellformedweb.org/CommentAPI/";a:1:{s:10:"commentRss";a:1:{i:0;a:5:{s:4:"data";s:114:"http://blog.astrumfutura.com/2010/09/contributing-to-zend-framework-2-0-is-free-hurry-before-this-offer-ends/feed/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:38:"http://purl.org/rss/1.0/modules/slash/";a:1:{s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:2:"17";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}}}i:3;a:6:{s:4:"data";s:47:"
		
		
		
		
		
				
		
		

		
		
			
			
		
		";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";s:5:"child";a:5:{s:0:"";a:7:{s:5:"title";a:1:{i:0;a:5:{s:4:"data";s:78:"Zend Framework Proposal: Zend\Html\Filter (HTML Sanitisation And Manipulation)";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"link";a:1:{i:0;a:5:{s:4:"data";s:111:"http://blog.astrumfutura.com/2010/09/zend-framework-proposal-zendhtmlfilter-html-sanitisation-and-manipulation/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:120:"http://blog.astrumfutura.com/2010/09/zend-framework-proposal-zendhtmlfilter-html-sanitisation-and-manipulation/#comments";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:7:"pubDate";a:1:{i:0;a:5:{s:4:"data";s:31:"Mon, 06 Sep 2010 07:33:00 +0000";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"category";a:3:{i:0;a:5:{s:4:"data";s:11:"PHP General";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:1;a:5:{s:4:"data";s:12:"PHP Security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:2;a:5:{s:4:"data";s:14:"Zend Framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"guid";a:1:{i:0;a:5:{s:4:"data";s:35:"http://blog.astrumfutura.com/?p=423";s:7:"attribs";a:1:{s:0:"";a:1:{s:11:"isPermaLink";s:5:"false";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:11:"description";a:1:{i:0;a:5:{s:4:"data";s:318:"For a while now, I&#8217;ve been keen to build a HTML Sanitisation solution for PHP. Where else would I end up putting it other than in Zend Framework? As I&#8217;ve explored in past articles [1] [2], HTML Sanitisation in PHP is a very inconsistent practice. Sanitisers like HTMLPurifier are very secure out of the box";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:32:"http://purl.org/dc/elements/1.1/";a:1:{s:7:"creator";a:1:{i:0;a:5:{s:4:"data";s:14:"Pádraic Brady";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:40:"http://purl.org/rss/1.0/modules/content/";a:1:{s:7:"encoded";a:1:{i:0;a:5:{s:4:"data";s:2577:"<div class="tweetmeme_button" style="float: right; margin-left: 10px;">
			<a href="http://api.tweetmeme.com/share?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F09%2Fzend-framework-proposal-zendhtmlfilter-html-sanitisation-and-manipulation%2F"><br />
				<img src="http://api.tweetmeme.com/imagebutton.gif?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F09%2Fzend-framework-proposal-zendhtmlfilter-html-sanitisation-and-manipulation%2F&amp;source=padraicb&amp;style=normal&amp;service=bit.ly&amp;service_api=padraic%3AR_94101570b7e190f3de921bc15bb9438d&amp;o=http%3A%2F%2Fblog.astrumfutura.com%2Ffeeds%2Findex.rss2&amp;b=2" height="61" width="50" /><br />
			</a>
		</div>
<p>For a while now, I&#8217;ve been keen to build a HTML Sanitisation solution for PHP. Where else would I end up putting it other than in Zend Framework? As I&#8217;ve explored in past articles [<a href="http://blog.astrumfutura.com/archives/430-HTML-Sanitisation-Benchmarking-With-Wibble-ZF-Proposal.html">1</a>] [<a href="http://blog.astrumfutura.com/archives/431-HTML-Sanitisation-The-Devils-In-The-Details-And-The-Vulnerabilities.html">2</a>], HTML Sanitisation in PHP is a very inconsistent practice. Sanitisers like HTMLPurifier are very secure out of the box but undeniably slow and resource intensive while others based on regular expression powered HTML parsing are much faster but tend to lose out a lot in the security stakes. Isn&#8217;t it possible to create a sanitiser that is both secure by default and performs well?</p>
<p>This was the core of the idea that became Wibble, my prototype for Zend\Html\Filter. Wibble borrowed sanitisation routines from a few programming languages to ensure secure operation, but relied entirely on PHP DOM and HTML Tidy for speed and HTML parsing. The resulting prototype was benchmarked [<a href="http://blog.astrumfutura.com/archives/430-HTML-Sanitisation-Benchmarking-With-Wibble-ZF-Proposal.html">1</a>] which proved that while Wibble could be faster than even regular expression based sanitisers (in scenarios where HTML was being manipulated) it most definitely would be faster than HTMLPurifier &#8211; without sacrificing security. Thus Wibble is capable of the best of both worlds &#8211; security and performance. The existing tradeoff in current solutions no longer applies.</p>
<p>You may read and comment on the proposal here: <a href="http://framework.zend.com/wiki/pages/viewpage.action?pageId=25002168">http://framework.zend.com/wiki/pages/viewpage.action?pageId=25002168</a>. The proposal is up for review for Zend Framework 2.0.</p>
";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:36:"http://wellformedweb.org/CommentAPI/";a:1:{s:10:"commentRss";a:1:{i:0;a:5:{s:4:"data";s:116:"http://blog.astrumfutura.com/2010/09/zend-framework-proposal-zendhtmlfilter-html-sanitisation-and-manipulation/feed/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:38:"http://purl.org/rss/1.0/modules/slash/";a:1:{s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:1:"5";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}}}i:4;a:6:{s:4:"data";s:71:"
		
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		

		
		
			
			
		
		";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";s:5:"child";a:5:{s:0:"";a:7:{s:5:"title";a:1:{i:0;a:5:{s:4:"data";s:73:"HTML Sanitisation: The Devil’s In The Details (And The Vulnerabilities)";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"link";a:1:{i:0;a:5:{s:4:"data";s:105:"http://blog.astrumfutura.com/2010/08/html-sanitisation-the-devils-in-the-details-and-the-vulnerabilities/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:114:"http://blog.astrumfutura.com/2010/08/html-sanitisation-the-devils-in-the-details-and-the-vulnerabilities/#comments";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:7:"pubDate";a:1:{i:0;a:5:{s:4:"data";s:31:"Mon, 09 Aug 2010 21:00:31 +0000";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"category";a:11:{i:0;a:5:{s:4:"data";s:11:"PHP General";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:1;a:5:{s:4:"data";s:12:"PHP Security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:2;a:5:{s:4:"data";s:14:"Zend Framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:3;a:5:{s:4:"data";s:15:"html sanisation";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:4;a:5:{s:4:"data";s:12:"htmlpurifier";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:5;a:5:{s:4:"data";s:8:"phishing";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:6;a:5:{s:4:"data";s:11:"php general";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:7;a:5:{s:4:"data";s:12:"php security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:8;a:5:{s:4:"data";s:8:"rantings";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:9;a:5:{s:4:"data";s:3:"xss";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:10;a:5:{s:4:"data";s:14:"zend framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"guid";a:1:{i:0;a:5:{s:4:"data";s:35:"http://blog.astrumfutura.com/?p=422";s:7:"attribs";a:1:{s:0:"";a:1:{s:11:"isPermaLink";s:5:"false";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:11:"description";a:1:{i:0;a:5:{s:4:"data";s:323:"HTML Sanitisation (defined below) has been with us for a long time, ever since the first genius who came up with the idea of allowing potentially untrustworthy third party HTML to be dynamically patched into their own markup. The years have not taken this kindly, and third-party HTML inclusion has remained one of the most";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:32:"http://purl.org/dc/elements/1.1/";a:1:{s:7:"creator";a:1:{i:0;a:5:{s:4:"data";s:14:"Pádraic Brady";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:40:"http://purl.org/rss/1.0/modules/content/";a:1:{s:7:"encoded";a:1:{i:0;a:5:{s:4:"data";s:29019:"<div class="tweetmeme_button" style="float: right; margin-left: 10px;">
			<a href="http://api.tweetmeme.com/share?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F08%2Fhtml-sanitisation-the-devils-in-the-details-and-the-vulnerabilities%2F"><br />
				<img src="http://api.tweetmeme.com/imagebutton.gif?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F08%2Fhtml-sanitisation-the-devils-in-the-details-and-the-vulnerabilities%2F&amp;source=padraicb&amp;style=normal&amp;service=bit.ly&amp;service_api=padraic%3AR_94101570b7e190f3de921bc15bb9438d&amp;hashtags=html+sanisation,htmlpurifier,phishing,php+general,php+security,rantings,xss,zend+framework&amp;o=http%3A%2F%2Fblog.astrumfutura.com%2Ffeeds%2Findex.rss2&amp;b=2" height="61" width="50" /><br />
			</a>
		</div>
<p>HTML Sanitisation (defined below) has been with us for a long time, ever since the first genius who came up with the idea of allowing potentially untrustworthy third party HTML to be dynamically patched into their own markup. The years have not taken this kindly, and third-party HTML inclusion has remained one of the most complex and underappreciated vectors for security vulnerabilities.</p>
<p>In this article, I take a look at some of the solutions PHP developers rely upon to perform HTML Sanitisation. Mostly because few others have done it or written about such solutions in any great detail (at least publicly). HTML Sanitisation has a very low profile in PHP. It&#8217;s rarely mentioned, usually not understood all that well, and examining some of the solutions in this area with more deliberate attention is worth doing. Also, it&#8217;s valuable research since I am writing my own HTML Sanitisation library (bias alert!) for a future Zend Framework 2.0 proposal. Knowing what the competition is up to does no harm! Finally, I was simply curious. Nobody seems too pushed to look closely at all these HTML Sanitisation solutions despite the fact that there are other developers (I think) who wouldn&#8217;t touch most of them with a barge pole.</p>
<p>One somewhat remarkable example, just to illustrate why I figured this article was worth the time, is <a href="http://htmlpurifier.org/comparison">HTMLPurifier&#8217;s Comparison analysis</a> where HTMLPurifier is compared against a number of other HTML Sanitisers. The comparison is remarkable because it seems inclined to err on the side of giving HTMLPurifier&#8217;s competitors the benefit of the doubt. Unfortunately, this means the analysis is often flawed and its conclusions suspect. Also, it assists in legitimising other solutions in the minds of readers by making assumptions of safety. Not that this reflects on HTMLPurifier&#8217;s functionality, incidentally, which I have always maintained is the only HTML Sanitiser worth looking at.</p>
<p>Back on track…</p>
<h3>What is HTML Sanitisation?</h3>
<p>HTML is an amazingly dangerous thing. It can contain Javascript, CSS, or malformed markup, or even gigantic images that laugh at your dual 32&#8243; monitor setup. Each of these, in their own way, can damage the experience of an end user, whether it be by Cross-Site Scripting (XSS), Phishing or simply mangling the page until it&#8217;s unusable and/or defaced with scriptkiddie jibes.</p>
<p>There are two ways of dealing with these threats to the HTML output of an application: escape output so that the only HTML rendered by the browser is the application&#8217;s (anything else being neutered by HTML entities), or by sanitising output so that any additional HTML it contains, that is renderable by a browser, is stripped of any potentially damaging markup. This article concerns the second option.</p>
<p>HTML Sanitisation may therefore be defined as any means of filtering HTML to ensure that a) Cross-Site Scripting (XSS) vulnerabilities are removed, b) Phishing vulnerabilities are removed, c) the HTML is well formed and adheres to an acceptable HTML standard, and d) the HTML contains no obvious means of breaking expected web page rendering.</p>
<p>I won&#8217;t claim this is a perfect definition but it covers most of the salient points you&#8217;ll likely encounter.</p>
<p>So there are, broadly speaking, four primary objectives of HTML Sanitisation, any one of which is capable of preventing damage to end users or web application functionality (including javascript powered client side functionality). Each is, in its own way, quite a difficult proposition requiring suitable tools and specialised knowledge. However, with some objectives we can measure our success somewhat reliably. The question of this article being: how well do HTML Sanitisers in PHP measure up to these objectives?</p>
<h3>The Candidates</h3>
<p>Since this is intended as a brief examination (just a few million words long!), I decided to select four candidate HTML Sanitisers meeting certain conditions. These conditions included:</p>
<p>1. Having a release at some point in the past two years;<br />
2. Describing itself as a HTML sanitiser/filter to prevent Bad Things;<br />
3. Having a design clearly in line with an intent to filter XSS/Phishing; and<br />
4. Having no publicly acknowledged long standing security vulnerabilities.</p>
<p>The great part about applying these conditions is that I pretty much eliminated stacks of HTML Sanitisers (as some might claim them as being). Outside of those, it also eliminates anything users might misconstrue as a HTML Sanitiser (for example PHP&#8217;s strip_tags() function or Zend Framework&#8217;s Zend_Filter_StripTags class). What we are left with is pretty thin on the ground, but fits what I&#8217;d expect a reasonably educated PHP developer to swing with. From what remained, I selected four candidates (or maybe these were the only four left &#8211; I&#8217;ll never tell):</p>
<p>1. PEAR&#8217;s HTML_Safe<br />
2. htmLawed<br />
3. WordPress&#8217; Kses<br />
4. HTMLPurifier</p>
<p>With four candidates in tow, I proceeded to examine each against the four objectives of HTML Sanitisation I noted earlier. Just to emphasise to readers, this examination was not so in-depth as to identify every possible flaw or issue with each candidate. My intent was to attempt to locate one security vulnerability and assess each candidate in general terms for the other non-security related HTML Sanitisation objectives.</p>
<p>Before I go any further, let me clarify that all security vulnerabilities discovered were notifed almost immediately to the parties responsible for each candidate solution. All such parties confirmed receipt of these reports within one week, and all were given a period (approx. six or more weeks to today) in which to apply fixes, make new releases, update documentation, perform additional security reviews, etc. I&#8217;ve sat on this article for a long time. Regardless of the effectiveness of any such actions (or lack of action as the case may be), this article discloses all perceived security vulnerabilities discovered during my examination whether or not all parties agree with my opinion. In some cases a disclosure may clearly indicate a fundamental flaw in the underlying design of the candidate. In these cases, it was emphasised to the responsible parties that reported vulnerabilities were limited to the scope of my examination and that I believed it was likely that additional and possibly related vulnerabilities remained unreported but easily discoverable as a result of public disclosure. This concludes my rendition of &#8220;Cover Your Ass&#8221; <img src='http://blog.astrumfutura.com/wp-includes/images/smilies/icon_wink.gif' alt=';)' class='wp-smiley' /> .</p>
<p>Note that all discussions below relate to the whichever version of each candidate solution was initially examined (before any fixed releases). I have noted resolutions as necessary for each.</p>
<h3>PEAR&#8217;s HTML_Safe</h3>
<p>To get us started, <a href="http://pear.php.net/package/HTML_Safe">PEAR&#8217;s HTML_Safe</a> is one of the older candidates despite its examined release being in April 2010 (the previous release being a beta in 2005). HTML_Safe&#8217;s description states that &#8220;This parser strips down all potentially dangerous content within HTML&#8221;. HTML_Safe operates on the basis of parsing HTML with regular expressions and applying filtering logic which is dependent on predefined blacklists of potentially harmful elements, attributes and CSS properties.</p>
<p>Unfortunately, HTML_Safe&#8217;s blacklists prove its undoing. The problem with blacklists is that they require constant attention and updates for new problems. A cursory examination of the CSS property blacklist showed that it omitted many browser specific CSS properties such as -ms-behavior. The -ms-behavior CSS property (<a href="http://msdn.microsoft.com/en-us/library/cc304082%28VS.85%29.aspx#extensions_css">specific to Internet Explorer 8</a>) may contain as a value a URI reference to a locally hosted HTC file (which contains executable Javascript). While such a file would need to exist on the local domain, this is obviously a security vulnerability in that it allows the execution of any arbitrary Javascript an attacker can store or reuse on the local domain thus opening up XSS possibilities.</p>
<p>HTML_Safe also has another vulnerability shared by practically all HTML Sanitisation solutions based on the use of regular expressions. Regular expression parsing typically assumes that all HTML special characters are encoded in ASCII (an encoding subset which is common across other encodings such as ISO-8859-1 and UTF-8). However, UTF-7 encodes the greater than (>) and less than (<) characters differently. This means that typical regular expression parsing does not detect these characters when encoded in UTF-7. If you can't detect them, you can't sanitise them! This sanitisation bypass requires a secondary vulnerability where an attacker either forces a webpage containing unsanitised UTF-7 encoded markup to be rendered with a charset of UTF-7 (IE has vulnerabilities here, as do some versions of Firefox) or where the target application actually allows a user to select a nonsensical custom character set (as happened with Google and Yahoo when struck with this same exploit, and several CMS applications as recently as last Spring).</p>
<p>Finally, HTML_Safe's blacklisting also misses out on CSS properties not directly tied to XSS (e.g. position), but which may be used to perform Phishing attacks by using CSS styling to alter or overlay HTML elements. This could, for example, allow an attacker to re-style their injected HTML to replace (as in positioning above) specific page elements (if not the entire page). This can lead to <a href="http://en.wikipedia.org/wiki/Clickjacking">Clickjacking</a> among other forms of Phishing.</p>
<p>In terms of HTML well formedness, HTML_Safe does not necessarily emit standards compliant or well formed HTML, nor does it check some other common page breaking tactics such as overlarge images as a precaution.</p>
<p>HTML_Safe may well be the least secure of our four candidates. Its use of blacklisting, its relative age, and a lack of peer review have left it woefully outdated for the task of HTML Sanitisation. In short, it should be avoided at all costs and my main request to PEAR at the time of reporting the above vulnerabilities was to seriously consider removing it from PEAR. Personally, I find it almost tragic that a library of such limited capability may benefit from PEAR&#8217;s reputation and lead to users trusting it over far more secure alternatives.</p>
<p>Of the issues noted above, the UTF-7 vulnerability has been resolved in a new release. The CSS blacklist has not yet been revised though I remain confident that the security advisory will go out any day now. PEAR does do security advisories, right? My recommendation, as originally suggested, remains that HTML_Safe should be removed, or overhauled, given it is not up to the task of HTML Sanitisation in its current condition. Blacklists are simply the worst approach ever to HTML sanitisation.</p>
<h3>htmLawed</h3>
<p>Our second candidate is, at least based on Google&#8217;s omnipotence, one of the more popular open source standalone HTML Sanitisers. <a href="http://www.bioinformatics.org/phplabware/internal_utilities/htmLawed">htmLawed</a> has garnered a reputation as something of a rebellious spirit built for speed, a stark contrast to the slow resource intensive operation of HTMLPurifier with which is often compared. htmLawed&#8217;s description states that it is &#8220;PHP code to purify &#038; filter HTML&#8221; and that it can &#8220;make HTML markup in text secure and standard-compliant&#8221;.</p>
<p>The problem with htmLawed is that its operation is not much more than a very short stone&#8217;s throw away from HTML_Safe. On the face of it, htmLawed is significantly more complex than HTML_Safe, being loosely based on Kses (an older HTML Sanitisation script). Its documentation is also huge, finely detailed, and packed full of options. It&#8217;s source code is also complex and heavily obscured (presumably to discourage anyone from trying to examine it too closely). But&#8230;complexity and options a HTML Sanitiser does not make.</p>
<p>Similar to HTML_Safe, htmLawed carries no functionality to thwart character encoding based attacks. The UTF-7 exploit as described for PEAR&#8217;s HTML_Safe works perfectly well.</p>
<p>In addition, htmLawed has a number of oddities which are not vulnerabilities but may potentially become such in the future. These are related to attempts by htmLawed to fix insecure attribute values and CSS values. I have no idea why htmLawed tries to fix them (just remove them!), but the results come very close to enabling reconstructive logic based attacks (i.e. where you can trick a fixing mechanism to reconstruct a more obvious attempt at a vulnerability into a less obvious but equally dangerous one). I can&#8217;t say these are anything more than oddities however. One example, is that you can get the parser to create a CSS string containing something like &#8220;exp ress ion&#8221; (expression properties allow the execution of Javascript). The spaces in the string prevent it from being used by all current browsers, but what if a new browser release decides to ignore a little whitespace? Several other oddities also exist but are either harmless or fixed in the most recent htmLawed release.</p>
<p>Back firmly in current reality, htmLawed&#8217;s CSS filtering is seriously flawed. For example, it does not filter out the CSS behavior property which leads to the same result as it would for HTML_Safe&#8217;s allowance of -ms-behavior, the execution of local domain hosted HTC files containing Javascript.</p>
<p>And, again, htmLawed is open to the exact same Phishing and Clickjacking vulnerabilities as HTML_Safe, allowing all CSS position/height/width and other properties capable of re-styling web pages.</p>
<p>htmLawed is not quite as easy to fool as HTML_Safe, but both share a remarkably similar lack of attention to specific areas of HTML Sanitisation. The conclusion I&#8217;ve come to hold is that both of these libraries (and others in the wild) are reading from the same book. Which might sound ridiculous before you consider that these libraries all seem to revolve around the year 2005 or so &#8211; the same period when Kses was King of HTML Sanitisation. There&#8217;s no originality when you write new libraries in various styles which all follow the exact same assumptions and knowledge level.</p>
<p>htmlLawed performs tag balancing and other cleanup tasks. Nevertheless, it will not necessarily output wellformed or standards compliant HTML. You should bring ext/tidy to the party as a post-processor.</p>
<p>My main gripe with htmLawed, besides the above, is that it does not appear these are going to be fixed any time soon. The script&#8217;s author has taken the approach that htmLawed filters HTML, and only HTML. Its CSS filtering can&#8217;t be trusted and is not secure, and this IS part of HTML Sanitisation (HTML contains CSS!). Nevertheless, htmLawed documentation has been updated since my reports to clarify what developers may need to do before using htmLawed (i.e. normalise input character encoding, ensure all CSS is stripped/disabled or sanitised by another process, etc.). In short, htmLawed is not even remotely in the race as a fully featured HTML Sanitiser. It is lacking too many features, or using features which are obviously incomplete, and it is pushing too much complex responsibilities on end users who we all know will never bother doing them.</p>
<p>The issues noted above have not, to date, been fully resolved to my satisfaction though the updated documentation means I can&#8217;t call them vulnerabilities anymore. While documentation updates and minor fixes have resulted in some improvement and clarification, it appears that the fundamental flaws in CSS sanitisation and character encoding will not be implemented until some future unscheduled major revision of htmLawed (encoding has been documented as an end user concern instead). In effect, the security vulnerabilities reported resulted not in fixes, but in pushing the fixes back to the end users to deal with and denying them as a responsibility of htmLawed. In my book, that simply removes htmLawed entirely as a usable HTML sanitiser. Pushing responsibility back to users may let you off the security vulnerability hook but it does call the entire description and goals of htmLawed into question.</p>
<p>Users are advised to ensure that they follow the documentation to the letter (read it in detail!) in disabling all CSS styling and enabling safe mode for htmLawed (sanitisation is disabled by default for this one). Using ext/iconv to do some minimal character encoding normalisation is also highly recommended. As with PEAR, there has been no formal security advisory issued, also the release notes for the latest release make no reference to any security vulnerability existing.</p>
<h3>WordPress (Kses)</h3>
<p>Candidate three is WordPress 3.0, or more specifically <a href="http://core.svn.wordpress.org/trunk/wp-includes/kses.php">the Kses script bundled with WordPress</a> that is used internally for HTML Sanitisation. It should be noted that while the original Kses is stuck in 2005 (and should be avoided like the plague), WordPress have heavily updated their internal copy. This creates a viable HTML Sanitisation solution which is simple to extract for personal use (just needs a handful of extra functions borrowed from an includes file), and which may well be the defacto winner in the popularity stakes just because it&#8217;s a core part of everyone&#8217;s favourite blogging platform.</p>
<p>What could possibly go wrong? Well, surprisingly not as much as I was half expecting after my earlier candidates!</p>
<p>WordPress&#8217; Kses proved far more challenging than the previous two candidates. It&#8217;s obvious that the widespread use of WordPress has enforced constant peer review and improvement. Nevertheless, where there&#8217;s a will (and a quiet afternoon), there&#8217;s a way.</p>
<p>WordPress&#8217; Kses first of all offers no protection when used as a standalone sanitiser against character encoding attacks, thus the previously described UTF-7 XSS attack works quite well. I do NOT consider this a security vulnerability since the use of Kses within WordPress prevents manipulation of the HTML&#8217;s declared charset (though presumably this protection could be mangled by some WordPress template author). Nevertheless, for anyone using Kses in standalone mode you should note that character encoding normalisation is necessary and should be implemented.</p>
<p>Fast forward three coffees, and it finally clicked that Kses did have one obvious flaw in that it uses a little blacklisting for CSS filtering. In short, it removes all CSS attribute values which contain any of the characters /, \, * and  (. It&#8217;s actually very clever (in that it&#8217;s indiscriminately simple) since it just removes CSS using these characters altogether. Unfortunately, it never considered the use of the right-handed curly brace, }. Under all versions of Internet Explorer, in either quirks or standards mode, the right curly brace is treated as a CSS terminator (i.e. just like a semi-colon). This means that something like &#8220;position: absolute; top: 5px; left: 10px;&#8221; can be written for Internet Explorer as &#8220;position: absolute} top: 5px} left: 10px}&#8221;. IE extends another unwanted helping hand&#8230; The result is that such CSS styling values are not intercepted by Kses (which relies on semi-colon terminators), and may allow for Phishing and Clickjacking attacks where Kses filtered user input is rendered to an end user from WordPress.</p>
<p>After those three coffees and some head banging, I thanked my numb brain for finally giving me something and left well enough alone. Later on, I also reported to the WordPress team that Internet Explorer in quirks mode (doesn&#8217;t work in standards mode) also accepted the equals sign in place of a colon, i.e. &#8220;position: absolute;&#8221; could be written as &#8220;position=absolute;&#8221; or even &#8220;position=absolute}&#8221;. This is of far less concern than the previous issue &#8211; and more of a funny aside on IE&#8217;s incredible silliness.</p>
<p>As with previous candidates, Kses will not always output well formed HTML not will it check for other page breaking tactics. Again, this will require some custom checks and perhaps ext/tidy in some cases.</p>
<p>WordPress&#8217; Kses is surprisingly (well, it should be!) adept at the HTML Sanitisation game. If it bundled encoding normalisation, and packed HTML tidying and a few other bits and pieces I&#8217;d almost use it myself. Almost. At the end of the day, however, I just don&#8217;t trust regular expressions enough.</p>
<p>The issues noted above were fixed in WordPress 3.0.1 released in late July 2010 (and weeks beforehand in SVN). The reported Phishing issue was mysteriously absent from the list of 54 fixed issues for 3.0.1, which isn&#8217;t really all that surprising (would not have been a public issue anywhere) but it would have been nice to see a public disclosure from the vendor before I published this article.</p>
<h3>HTMLPurifier</h3>
<p><a href="http://www.htmlpurifier.org">HTMLPurifier</a> is the brain child (no doubt with Angelina Jolie) of Edward Z. Yang. In short it is nothing remotely like the other HTML Sanitisation candidates. It bundles a HTML parser/validator/supercomputer (rumour says it might be The Stig&#8217;s brain). HTMLPurifier describes itself with &#8220;HTML Purifier is a standards-compliant HTML filter library written in PHP. HTML Purifier will not only remove all malicious code (better known as XSS) with a thoroughly audited, secure yet permissive whitelist, it will also make sure your documents are standards compliant, something only achievable with a comprehensive knowledge of W3C&#8217;s specifications.&#8221;</p>
<p>Short answer. I completely failed to find anything that got past it. I tried. Then I tried some more. Then I tried multiple caffeine injections but to no avail. It just sat there looking smug. HTMLPurifier is seemingly impervious to pretty much anything. Worse, it refused to produce any mangled attributes, or reconstructions, or anything else I normally expect of a typical HTML Sanitisation solution.</p>
<p>Out of four candidates, HTMLPurifier was the only one to successfully meet all four objectives of HTML Sanitisation. It&#8217;s only problem? It eats RAM and sucks CPU cycles far more than any other candidate. A point which at least some HTML Sanitisers may note as a disadvantage since they can&#8217;t hang it on anything else.</p>
<p>Since I cannot just leave it there, and since it is always worth noting, this does not mean that HTMLPurifier is invincible. The problem with the world of Cross-Site Scripting is that there are constantly evolving new ways to attack users. HTMLPurifier has fixed several vulnerabilities in the past, and these are publicly disclosed by the author (as security advisories even). Many of them are reported directly by discoverers of new vectors which adds to HTMLPurifier security in one respect since it gets such attention. The author is also quite proactive about locating and researching fixes to possible future vulnerabilities.</p>
<p>HTMLPurifier is, quite simply, the only fully functioning and fully featured HTML Sanitiser in PHP. It literally stands alone.</p>
<h3>What Does It All Mean?</h3>
<p>Besides the fact that PHP developers are sheep to the slaughter? It means that HTML Sanitisation is incredibly misunderstood even by the authors of HTML Sanitisation solutions. It means that such solutions have minimal peer review by individuals who are relatively knowledgeable of security issues. It probably means that the days of combating XSS and Phishing and other concerns linked to HTML Sanitisation are far from over, at least for PHP.</p>
<p>Consider the nature of the vulnerabilities. None of them are particularly obscure or poorly documented in the public domain. There are several excellent sources of XSS/Phishing vectors for browsers, but it truly appears that everyone relies entirely on just one &#8211; the <a href="http://ha.ckers.org/xss.html">XSS (Cross Site Scripting) Cheatsheet</a> and it&#8217;s blatantly obvious that it&#8217;s the only source for XSS vectors utilised by most solutions in whatever passes for their testing (I doubt anyone checks the ha.ckers.org forum for more either). This is a limited exposure issue &#8211; if you focus on the same subset of possible exploits and ignore anything else, you are entirely at the mercy of a single source of knowledge that omits quite a lot (the XSS Cheatsheet doesn&#8217;t contain all possible exploits &#8211; far from it!). For example, the CSS vulnerability approach for WordPress Kses is clearly documented on the <a href="http://heideri.ch/jso/#46">HTML5 Security Cheatsheet</a> but not mentioned anywhere on the more commonly referenced XSS Cheatsheet. It&#8217;s a very old CSS vector.</p>
<p>In addition, many HTML Sanitisation solutions share common approaches and vulnerabilities. I was only looking for one vulnerability, but cross checks netted those in common. This is one indication of an isolated evolutionary line &#8211; everybody feeds off everybody else&#8217;s work in the area with no attempt to look outside the PHP house to see what the weather is like over in Rubyville or Javatown (it looks really sunny in both incidentally) or even just to keep up to date on new resources, ideas and research. More interestingly, all this in-feeding seems to start with Kses in 2005. It&#8217;s like the past six years dropped into a timeless black hole insulated from the harsh realities of Terra Firma even as tidal forces slowly tore them apart. The singularity being a library from 2005 that is no longer maintained (outside of WordPress).</p>
<p>What is surprising, is that this isn&#8217;t surprising to me anymore. It&#8217;s par for the course in PHP and that hasn&#8217;t changed since the 90s. I love PHP to bits, but it&#8217;s a language that is tragically short on security expertise, and where a security expert can be nothing more than someone who read a book long ago and who has no incentive to move beyond the obvious or do something extraordinary &#8211; like using Google. If this article achieves nothing more than a blip on some faraway radar forgotten the next day as the download count for HTML_Safe, htmLawed, and all the other solutions I haven&#8217;t examined, goes unchanged then at least I got a blip. It&#8217;s a start. Maybe it&#8217;s a few less XSS reports on Bugtraq or a few less people choosing an insecure solution because it claims to be fast and routinely misleads people about its efficacy in between taking senseless potshots at the only reliable solution out there. Maybe a few more developers will question all these miraculous HTML sanitisers and stop believing their summary descriptions at face value.</p>
<p>Developers need to start using their heads when it comes to selecting any security related solution. It&#8217;s truly amazing to see developers recommend something purely on the basis of speed, or to watch them argue against all logic in support of an insecure option and just plain ignore the security implications (or assume there are none, or point at an RFC and misquote/misread it). The whole point of a security related solution IS security. If you want to compromise security to gain performance then at least be brutally honest about what it entails for the applications you build.</p>
<p>Do yourself a favour, use HTMLPurifier. And Ambush Commander, update the fracking comparison page already! <img src='http://blog.astrumfutura.com/wp-includes/images/smilies/icon_wink.gif' alt=';)' class='wp-smiley' /> </p>
";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:36:"http://wellformedweb.org/CommentAPI/";a:1:{s:10:"commentRss";a:1:{i:0;a:5:{s:4:"data";s:110:"http://blog.astrumfutura.com/2010/08/html-sanitisation-the-devils-in-the-details-and-the-vulnerabilities/feed/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:38:"http://purl.org/rss/1.0/modules/slash/";a:1:{s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:2:"29";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}}}i:5;a:6:{s:4:"data";s:68:"
		
		
		
		
		
				
		
		
		
		
		
		
		
		
		

		
		
			
			
		
		";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";s:5:"child";a:5:{s:0:"";a:7:{s:5:"title";a:1:{i:0;a:5:{s:4:"data";s:56:"HTML Sanitisation Benchmarking With Wibble (ZF Proposal)";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"link";a:1:{i:0;a:5:{s:4:"data";s:92:"http://blog.astrumfutura.com/2010/07/html-sanitisation-benchmarking-with-wibble-zf-proposal/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:101:"http://blog.astrumfutura.com/2010/07/html-sanitisation-benchmarking-with-wibble-zf-proposal/#comments";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:7:"pubDate";a:1:{i:0;a:5:{s:4:"data";s:31:"Thu, 08 Jul 2010 19:50:31 +0000";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"category";a:10:{i:0;a:5:{s:4:"data";s:11:"PHP General";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:1;a:5:{s:4:"data";s:12:"PHP Security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:2;a:5:{s:4:"data";s:14:"Zend Framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:3;a:5:{s:4:"data";s:9:"benchmark";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:4;a:5:{s:4:"data";s:11:"php general";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:5;a:5:{s:4:"data";s:12:"php security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:6;a:5:{s:4:"data";s:6:"wibble";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:7;a:5:{s:4:"data";s:3:"xss";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:8;a:5:{s:4:"data";s:14:"zend framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:9;a:5:{s:4:"data";s:11:"zf proposal";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"guid";a:1:{i:0;a:5:{s:4:"data";s:35:"http://blog.astrumfutura.com/?p=420";s:7:"attribs";a:1:{s:0:"";a:1:{s:11:"isPermaLink";s:5:"false";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:11:"description";a:1:{i:0;a:5:{s:4:"data";s:285:"In January of this year, I had the idea of writing a HTML Sanitiser for PHP. Why not? All PHP has is HTMLPurifier and a bunch of random solutions that are about as secure as the average wooden gate. If you think that&#8217;s harsh, wait for my next blog post . HTMLPurifier is the only";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:32:"http://purl.org/dc/elements/1.1/";a:1:{s:7:"creator";a:1:{i:0;a:5:{s:4:"data";s:14:"Pádraic Brady";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:40:"http://purl.org/rss/1.0/modules/content/";a:1:{s:7:"encoded";a:1:{i:0;a:5:{s:4:"data";s:8275:"<div class="tweetmeme_button" style="float: right; margin-left: 10px;">
			<a href="http://api.tweetmeme.com/share?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F07%2Fhtml-sanitisation-benchmarking-with-wibble-zf-proposal%2F"><br />
				<img src="http://api.tweetmeme.com/imagebutton.gif?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F07%2Fhtml-sanitisation-benchmarking-with-wibble-zf-proposal%2F&amp;source=padraicb&amp;style=normal&amp;service=bit.ly&amp;service_api=padraic%3AR_94101570b7e190f3de921bc15bb9438d&amp;hashtags=benchmark,php+general,php+security,wibble,xss,zend+framework,zf+proposal&amp;o=http%3A%2F%2Fblog.astrumfutura.com%2Ffeeds%2Findex.rss2&amp;b=2" height="61" width="50" /><br />
			</a>
		</div>
<p>In January of this year, I had the idea of writing a HTML Sanitiser for PHP. Why not? All PHP has is HTMLPurifier and a bunch of random solutions that are about as secure as the average wooden gate. If you think that&#8217;s harsh, wait for my next blog post <img src='http://blog.astrumfutura.com/wp-includes/images/smilies/icon_wink.gif' alt=';)' class='wp-smiley' /> . HTMLPurifier is the only secure by default HTML Sanitiser in PHP. Fact. But the darn thing is gigantic and slow. That has never stopped me using it (for years), even if I had to do a little funky engineering so I could minimise the performance hit. Other developers, however, have often abandoned HTMLPurifier, falling into the trap of believing that alternative solutions will serve them just as well.</p>
<p>That&#8217;s the state of HTML Sanitisation in PHP &#8211; pick a big slow library that crushes Cross-Site Scripting and Phishing attacks, or use yet another regular expression based sanitiser that a) barely manages a fraction of HTMLPurifier&#8217;s features and b) can probably be exploited by any scriptkiddie working with a stack of data cards. It says an awful lot about security standards among PHP developers that such delusions are uncomprehendingly rampant.</p>
<p>In case you haven&#8217;t noticed, I&#8217;m biased. Sue me.</p>
<p>I have opined since forever that regular expression sanitisers are nothing short of insane. Since the problem with HTMLPurifier is speed and size, I started thinking about ways to build something like HTMLPurifier that was fast, small and almost as feature packed as HTMLPurifier. At first, this sounds like an impossible task. The typical suggestion is to use regular expressions, but I&#8217;m not completely insane&#8230;yet. Instead I borrowed a concept called a DOM Filter and chucked in a helpful dose of HTML Tidy. The result was <a href="http://github.com/padraic/wibble">Wibble</a>.</p>
<p>Wibble is basically a DOM Filter. It loads up HTML into PHP DOM, applies a set of filters against all nodes in the DOM, passes the output through HTML Tidy, and then hands it back to the user &#8211; sanitised and well-formed. It&#8217;s almost stupid in its obviousness. Better, this allows Wibble to skip regular expression dependence. It operates far more like HTMLPurifier by relying on a DOM representation (no string parsing to funk around with) partnered with Tidy for cleanup.</p>
<p>Of course, there have to be regular expressions somewhere. And whitelists. And other stuff. Wibble is really an amalgamation of borrowed concepts. It&#8217;s hard to be too original in HTML Sanitisation because originality is a good way to shoot yourself in the foot (hence regex is EVIL!), so I wasn&#8217;t going to spend too long digging my own grave when there is a wealth of sanitisation resources in the programming world. Wibble&#8217;s approach borrows elements from Ruby&#8217;s loofah, Python&#8217;s HTML5Lib, and Java&#8217;s AntiSamy. Wibble mixes and matches from the useful design elements each of these offers, serving them up on top of PHP&#8217;s DOM and Tidy extensions with its own distinctive twists.</p>
<p>I completed the first Wibble prototype recently, so I figured that with something that was at that 90% point where the remaining 10% would be in-depth sanity testing, cleanup and documentation, it was time to see how it compared to some other PHP solutions (<a href="http://www.htmlpurifier.org">HTMLPurifier</a> and <a href="http://www.bioinformatics.org/phplabware/internal_utilities/htmLawed/" >HtmLawed</a>). I had some fairly conservative performance objectives so the results came as a pleasant surprise.</p>
<p>If you are a benchmark fiend, you can download and independently fiddle with my benchmark process from <a href="http://github.com/padraic/wibble-benchmarks">http://github.com/padraic/wibble-benchmarks</a>. Note that the current benchmark uses a Wibble prototype &#8211; there are additional elements that need to be added over time. The benchmark currently uses three sample snippets of HTML: Small (blog comment size), Medium (markup heavy with limited textual content), and  Big (markup light with lots of textual content). It operates by filtering each HTML sample 200 times with each benchmarked HTML sanitisation solution. Each iteration includes the instantiation and setup phases of each solution (where relevant) to reflect the most likely real world experience of using sanitisation as a once off (non-repeating in same request) process. I use PEAR&#8217;s Benchmark package to record the aggregate run time per loop of sanitisation tasks. All operations occur within one single PHP process with HTMLPurifier caching enabled (Wibble and HtmLawed do not use caching). Each solution is configured as close as possible to target total stripping of all HTML from the content.</p>
<p>You can view a sample result at <a href="http://gist.github.com/468426">http://gist.github.com/468426</a>.</p>
<p>The results show that both Wibble and HtmLawed outperform HTMLPurifier by a very wide margin. Wibble underperforms HtmLawed by a variable margin &#8211; from twice as slow on small to medium sized input, to four times slower on large inputs with minimal HTML tags. In Wibble&#8217;s slowest benchmark, it outperformed HTMLPurifier by a factor of four.</p>
<p>Wibble intent is to try and replicate the completeness of HTMLPurifier, so it&#8217;s speed deficit when compared to HtmLawed is expected (when stripping all tags). There is not a lot to be done to improve this specific benchmark result since Wibble does a lot of stuff behind the scenes like encoding normalisation, DOM manipulation and HTML tidying. It also does all three of these things far more consistently and completely than HtmLawed is capable of.</p>
<p>So how does Wibble match up against Big Daddy? Wibble is a prototype, so obviously it still has ground to gain in terms of features with HTMLPurifier. But on the most significant points it only has one specific problem &#8211; it&#8217;s not HTML 5 ready. Neither DOM or Tidy support HTML 5, though you can &#8220;pretend&#8221; it&#8217;s HTML 4.01 (or even XHTML 1.0) for HTML 5 fragments so long as you are aware Tidy will strip unsupported HTML 5 tags and attributes.</p>
<p>The other points are syncing up with HTMLPurifier quite nicely. Wibble will santitise all HTML by default using strict filters (i.e. by default it strips every tag and only outputs plain text). It handles multiple encodings including conversion if necessary. It outputs standards compliant (other than HTML 5) HTML or XHTML. It fixes all the usual page breaking stuff like unclosed tags and illegal tag nesting. It is entirely reliant on whitelists and strict validation rather than blacklists and loose reconstructive parsing. It includes minimal regular expression usage (only needed for attribute and CSS validation) based on regular expressions widely used and tested in other languages. While testing will (and must) continue, it has so far proven resistant to XSS and Phishing attacks. This can&#8217;t be absolutely assured until sufficient testing has been performed.</p>
<p>Otherwise, it will be interesting to see the final version of Wibble. HTMLPurifier has a tough reputation to follow, but having something which can even up the odds and do it with a pronounced advantage in speed will be really nice. Well, until someone needs to install it on CentOS <img src='http://blog.astrumfutura.com/wp-includes/images/smilies/icon_wink.gif' alt=';)' class='wp-smiley' /> .</p>
";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:36:"http://wellformedweb.org/CommentAPI/";a:1:{s:10:"commentRss";a:1:{i:0;a:5:{s:4:"data";s:97:"http://blog.astrumfutura.com/2010/07/html-sanitisation-benchmarking-with-wibble-zf-proposal/feed/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:38:"http://purl.org/rss/1.0/modules/slash/";a:1:{s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:2:"28";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}}}i:6;a:6:{s:4:"data";s:59:"
		
		
		
		
		
				
		
		
		
		
		
		

		
		
			
			
		
		";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";s:5:"child";a:5:{s:0:"";a:7:{s:5:"title";a:1:{i:0;a:5:{s:4:"data";s:36:"Zend Framework Community Review Team";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"link";a:1:{i:0;a:5:{s:4:"data";s:74:"http://blog.astrumfutura.com/2010/06/zend-framework-community-review-team/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:83:"http://blog.astrumfutura.com/2010/06/zend-framework-community-review-team/#comments";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:7:"pubDate";a:1:{i:0;a:5:{s:4:"data";s:31:"Tue, 08 Jun 2010 18:07:00 +0000";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"category";a:7:{i:0;a:5:{s:4:"data";s:11:"PHP General";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:1;a:5:{s:4:"data";s:12:"PHP Security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:2;a:5:{s:4:"data";s:14:"Zend Framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:3;a:5:{s:4:"data";s:11:"php general";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:4;a:5:{s:4:"data";s:12:"php security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:5;a:5:{s:4:"data";s:14:"zend framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:6;a:5:{s:4:"data";s:10:"zf cr team";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"guid";a:1:{i:0;a:5:{s:4:"data";s:35:"http://blog.astrumfutura.com/?p=421";s:7:"attribs";a:1:{s:0:"";a:1:{s:11:"isPermaLink";s:5:"false";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:11:"description";a:1:{i:0;a:5:{s:4:"data";s:316:"For those of you not presently keeping watch on the Contributors mailing list or IRC, a Community Review Team (CR Team) has been established to assist with contributions to the Zend Framework. The role of the team will take a bit of time to settle into and explore, but Matthew Weier O&#8217;Phinney summarised it as";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:32:"http://purl.org/dc/elements/1.1/";a:1:{s:7:"creator";a:1:{i:0;a:5:{s:4:"data";s:14:"Pádraic Brady";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:40:"http://purl.org/rss/1.0/modules/content/";a:1:{s:7:"encoded";a:1:{i:0;a:5:{s:4:"data";s:5001:"<div class="tweetmeme_button" style="float: right; margin-left: 10px;">
			<a href="http://api.tweetmeme.com/share?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F06%2Fzend-framework-community-review-team%2F"><br />
				<img src="http://api.tweetmeme.com/imagebutton.gif?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F06%2Fzend-framework-community-review-team%2F&amp;source=padraicb&amp;style=normal&amp;service=bit.ly&amp;service_api=padraic%3AR_94101570b7e190f3de921bc15bb9438d&amp;hashtags=php+general,php+security,zend+framework,zf+cr+team&amp;o=http%3A%2F%2Fblog.astrumfutura.com%2Ffeeds%2Findex.rss2&amp;b=2" height="61" width="50" /><br />
			</a>
		</div>
<p>For those of you not presently keeping watch on the Contributors mailing list or IRC, a Community Review Team (CR Team) has been established to assist with contributions to the Zend Framework. The role of the team will take a bit of time to settle into and explore, but Matthew Weier O&#8217;Phinney summarised it as follows:</p>
<blockquote><p>- Assist contributors in getting patches and features into existing components.<br />
  &#8211; Act as liaison for contacting a maintainer on behalf of a contributor<br />
  &#8211; If the maintainer refuses to accept a patch, act as an arbiter between the contributor and the maintainer<br />
  &#8211; If the maintainer does not respond after a set period of time, would evaluate and/or apply the patch for the contributor<br />
  &#8211; Would issue pull requests to the Zend team in such instances as the above<br />
- Identify orphaned components<br />
  &#8211; Would identify when a component is no longer under active maintenance<br />
  &#8211; Solicit volunteers to take over maintenance of orphaned components<br />
  &#8211; Decide when an orphaned component should be marked as such and scheduled for removal (Note: removal can only happen in major revisions)<br />
- Shepherd new proposals.<br />
  &#8211; Solicit community feedback on proposals<br />
  &#8211; Would put competing proposal authors in touch with each other to work on a unified proposal<br />
  &#8211; Provide feedback on proposals (including initial decision as to whether or not there is enough community interest in including the proposed functionality in the framework)<br />
  &#8211; Would notify the Zend team when a proposal is ready<br />
  &#8211; Would do initial code review on the proposal implementation<br />
  &#8211; Would notify the Zend team when the proposed feature is feature complete and ready to pull into the master branch</p></blockquote>
<p>So essentially, the CR Team will have an advisory/liason role as it pertains to the proposing and maintenance of components. You should note that it will have limited decision capability, and Zend will continue to issue final approval for new proposals. However, if you do have a proposal in the works (or in a queue already), the Team will doubtlessly soon be looking for you <img src='http://blog.astrumfutura.com/wp-includes/images/smilies/icon_wink.gif' alt=';)' class='wp-smiley' /> .</p>
<p>The purpose of the CR Team is to assist in streamlining the noted areas: proposals, patches, maintenance of orphaned/abandoned components and communications with Zend and component maintainers as needed. Streamlining is a broad term, and while the specifics will be discussed by the team, it will as noted include component reviews (hopefully on an ongoing basis), offering feedback/advice, and blackmailing the community to take over from absent maintainers <img src='http://blog.astrumfutura.com/wp-includes/images/smilies/icon_wink.gif' alt=';)' class='wp-smiley' /> .</p>
<p>The CR Team presently has seven members (IRC nicks in brackets where known):</p>
<p>Pádraic Brady (PadraicB)<br />
Rob Allen (Akrabat)<br />
Steven Brown<br />
Shaun Farrell (farrelley)<br />
Pieter Kokx (kokx)<br />
Dolf Schimmel (Freeaqingme)<br />
Ben Scholzen (DASPRiD)</p>
<p>Most of the names above probably sound horribly familiar (including me!).</p>
<p>The Team is comprised of a fairly broad segment of active Zend Framework contributors with a variety of backgrounds. Most of the CR Team is on IRC on a daily (or weekly) basis and well known from the mailing lists. It&#8217;s expected that the CR Team will serve for a fixed period (to be determined) and then have its membership reopened for review/replacements if needed. That process isn&#8217;t defined at the moment but we&#8217;ll get to it.</p>
<p>In the meantime, if you have any questions regarding the Community Review Team you can find many of us on IRC (#zftalk.dev on Freenode) and/or Twitter. You may also get our attention via the mailing lists. While it will take us a bit of time to spin up our engines and dig into our roles, you should be aware we are out there and willing to help. If you have any particularly urgent questions about proposals, patches or maintainance, I&#8217;m sure the Team will be happy to look at those while we&#8217;re gearing up for full operation.</p>
";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:36:"http://wellformedweb.org/CommentAPI/";a:1:{s:10:"commentRss";a:1:{i:0;a:5:{s:4:"data";s:79:"http://blog.astrumfutura.com/2010/06/zend-framework-community-review-team/feed/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:38:"http://purl.org/rss/1.0/modules/slash/";a:1:{s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:1:"6";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}}}i:7;a:6:{s:4:"data";s:65:"
		
		
		
		
		
				
		
		
		
		
		
		
		
		

		
		
			
			
		
		";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";s:5:"child";a:5:{s:0:"";a:7:{s:5:"title";a:1:{i:0;a:5:{s:4:"data";s:22:"Mockery 0.6.1 Released";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"link";a:1:{i:0;a:5:{s:4:"data";s:60:"http://blog.astrumfutura.com/2010/06/mockery-0-6-1-released/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:69:"http://blog.astrumfutura.com/2010/06/mockery-0-6-1-released/#comments";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:7:"pubDate";a:1:{i:0;a:5:{s:4:"data";s:31:"Wed, 02 Jun 2010 19:10:00 +0000";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"category";a:9:{i:0;a:5:{s:4:"data";s:11:"PHP General";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:1;a:5:{s:4:"data";s:12:"PHP Security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:2;a:5:{s:4:"data";s:14:"Zend Framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:3;a:5:{s:4:"data";s:12:"mock objects";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:4;a:5:{s:4:"data";s:7:"mockery";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:5;a:5:{s:4:"data";s:11:"php general";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:6;a:5:{s:4:"data";s:12:"php security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:7;a:5:{s:4:"data";s:12:"unit testing";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:8;a:5:{s:4:"data";s:14:"zend framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"guid";a:1:{i:0;a:5:{s:4:"data";s:35:"http://blog.astrumfutura.com/?p=419";s:7:"attribs";a:1:{s:0:"";a:1:{s:11:"isPermaLink";s:5:"false";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:11:"description";a:1:{i:0;a:5:{s:4:"data";s:439:"You can read more about Mockery at http://blog.astrumfutura.com/archives/427-Mockery-0.6-Released-PHP-Mock-Object-Framework.html. Mockery 0.6.1 includes a functional fix which ensures mocking classes containing variants of the __call() method with or without typehinting are correctly mocked/replaced. I have also downgraded the PHP dependency to 5.3.0 from 5.3.2 by request. Thanks to everyone who so far has offered feedback! Mockery has";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:32:"http://purl.org/dc/elements/1.1/";a:1:{s:7:"creator";a:1:{i:0;a:5:{s:4:"data";s:14:"Pádraic Brady";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:40:"http://purl.org/rss/1.0/modules/content/";a:1:{s:7:"encoded";a:1:{i:0;a:5:{s:4:"data";s:1662:"<div class="tweetmeme_button" style="float: right; margin-left: 10px;">
			<a href="http://api.tweetmeme.com/share?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F06%2Fmockery-0-6-1-released%2F"><br />
				<img src="http://api.tweetmeme.com/imagebutton.gif?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F06%2Fmockery-0-6-1-released%2F&amp;source=padraicb&amp;style=normal&amp;service=bit.ly&amp;service_api=padraic%3AR_94101570b7e190f3de921bc15bb9438d&amp;hashtags=mock+objects,mockery,php+general,php+security,unit+testing,zend+framework&amp;o=http%3A%2F%2Fblog.astrumfutura.com%2Ffeeds%2Findex.rss2&amp;b=2" height="61" width="50" /><br />
			</a>
		</div>
<p>You can read more about Mockery at <a href="http://blog.astrumfutura.com/archives/427-Mockery-0.6-Released-PHP-Mock-Object-Framework.html" >http://blog.astrumfutura.com/archives/427-Mockery-0.6-Released-PHP-Mock-Object-Framework.html</a>.</p>
<p>Mockery 0.6.1 includes a functional fix which ensures mocking classes containing variants of the __call() method with or without typehinting are correctly mocked/replaced. I have also downgraded the PHP dependency to 5.3.0 from 5.3.2 by request. Thanks to everyone who so far has offered feedback! Mockery has been downloaded a total of 274 times since it&#8217;s original release. Counting those of you doing it twice or three times on differing machines, that probably means around 100 or more people have installed Mockery (at a guess). Remember we have a mailing list if you wish to ask any in-depth questions, you can report issues or feature requests on Github, and I&#8217;m usually somewhere on IRC (and Twitter) in the evening times (GMT).</p>
";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:36:"http://wellformedweb.org/CommentAPI/";a:1:{s:10:"commentRss";a:1:{i:0;a:5:{s:4:"data";s:65:"http://blog.astrumfutura.com/2010/06/mockery-0-6-1-released/feed/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:38:"http://purl.org/rss/1.0/modules/slash/";a:1:{s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:1:"0";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}}}i:8;a:6:{s:4:"data";s:68:"
		
		
		
		
		
				
		
		
		
		
		
		
		
		
		

		
		
			
			
		
		";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";s:5:"child";a:5:{s:0:"";a:7:{s:5:"title";a:1:{i:0;a:5:{s:4:"data";s:50:"Mockery 0.6 Released – PHP Mock Object Framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"link";a:1:{i:0;a:5:{s:4:"data";s:84:"http://blog.astrumfutura.com/2010/05/mockery-0-6-released-php-mock-object-framework/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:93:"http://blog.astrumfutura.com/2010/05/mockery-0-6-released-php-mock-object-framework/#comments";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:7:"pubDate";a:1:{i:0;a:5:{s:4:"data";s:31:"Thu, 27 May 2010 16:05:00 +0000";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"category";a:10:{i:0;a:5:{s:4:"data";s:11:"PHP General";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:1;a:5:{s:4:"data";s:12:"PHP Security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:2;a:5:{s:4:"data";s:14:"Zend Framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:3;a:5:{s:4:"data";s:12:"mock objects";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:4;a:5:{s:4:"data";s:7:"mockery";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:5;a:5:{s:4:"data";s:4:"pear";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:6;a:5:{s:4:"data";s:11:"php general";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:7;a:5:{s:4:"data";s:12:"php security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:8;a:5:{s:4:"data";s:8:"test spy";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:9;a:5:{s:4:"data";s:14:"zend framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"guid";a:1:{i:0;a:5:{s:4:"data";s:35:"http://blog.astrumfutura.com/?p=418";s:7:"attribs";a:1:{s:0:"";a:1:{s:11:"isPermaLink";s:5:"false";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:11:"description";a:1:{i:0;a:5:{s:4:"data";s:367:"Mockery is a Mock Object framework for PHP, compatible with most unit testing frameworks including PHPUnit. Its purpose is to implement a lightweight grammer for the creation and testing of Mock Objects, Test Stubs, and Test Spies as an alternative to the built-in support offered by PHPUnit, etc. Mockery is hosted on Github (http://github.com/padraic/mockery) where";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:32:"http://purl.org/dc/elements/1.1/";a:1:{s:7:"creator";a:1:{i:0;a:5:{s:4:"data";s:14:"Pádraic Brady";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:40:"http://purl.org/rss/1.0/modules/content/";a:1:{s:7:"encoded";a:1:{i:0;a:5:{s:4:"data";s:9056:"<div class="tweetmeme_button" style="float: right; margin-left: 10px;">
			<a href="http://api.tweetmeme.com/share?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F05%2Fmockery-0-6-released-php-mock-object-framework%2F"><br />
				<img src="http://api.tweetmeme.com/imagebutton.gif?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F05%2Fmockery-0-6-released-php-mock-object-framework%2F&amp;source=padraicb&amp;style=normal&amp;service=bit.ly&amp;service_api=padraic%3AR_94101570b7e190f3de921bc15bb9438d&amp;hashtags=mock+objects,mockery,pear,php+general,php+security,test+spy,zend+framework&amp;o=http%3A%2F%2Fblog.astrumfutura.com%2Ffeeds%2Findex.rss2&amp;b=2" height="61" width="50" /><br />
			</a>
		</div>
<p>Mockery is a Mock Object framework for PHP, compatible with most unit testing frameworks including PHPUnit. Its purpose is to implement a lightweight grammer for the creation and testing of Mock Objects, Test Stubs, and Test Spies as an alternative to the built-in support offered by PHPUnit, etc.</p>
<p>Mockery is hosted on Github (<a href="http://github.com/padraic/mockery">http://github.com/padraic/mockery</a>) where you can find an extensive README covering its API and uses. The Mockery 0.6 release may be installed from the SurviveTheDeepEnd.com PEAR channel at <a href="http://pear.survivethedeepend.com">http://pear.survivethedeepend.com</a>.</p>
<p>Mockery 0.6 features:</p>
<p>- Full Mock Object and Test Stub support<br />
- Lightweight fluent API<br />
- Flexible mocking and stubbing<br />
- Object Interaction Recording<br />
- Natural language syntax and expectation constructs<br />
- Supports generic (untyped) mock objects for rapid prototyping<br />
- Simple partial mocking of real objects<br />
- Both local and global Mock Object call ordering<br />
- Built-in return value queue for repeated method calls<br />
- Support for default expectations<br />
- Support for expectation replacement and stacking<br />
- Fluent API/Law of Demeter mocking</p>
<p>If that sounds complex, it&#8217;s not! Mockery can be picked up and used with little study.</p>
<h4>Why Mockery?</h4>
<p>Mockery&#8217;s objective is to simplify Mock Objects in PHP while maintaining significant flexibility and a default level of intuitive behaviour. In Mockery, Mock Objects behave exactly as you write them with liberal interpretations otherwise applied. Mockery was born out of my own need to innovate the use of Mock Objects in PHP and draw away from the original import of aging Mocking approaches from Java. While Java (and almost every other programming language) has been steadily progressing its mock object libraries, and complementing them with new solutions, PHP has a relatively static approach depending on similarly static library components. That result has seen solutions using clunky APIs, poorly described syntax and behaviour, a lack of focus on the practice of using Mock Objects, user confusion, and raised barriers to new programmers trying to learn about Mock Objects. Mockery is one potential solution to these problems. Also, as a dedicated Test-Driven Design user, I really want something that clicks immediately and doesn&#8217;t have any gotchas.</p>
<h4>Installation</h4>
<p>Mockery may be installed from its PEAR channel using:</p>
<p>    pear channel-discover pear.survivethedeepend.com<br />
    pear install deepend/Mockery</p>
<p>Mockery is written in PHP 5.3 (I know, but all you 5.2 users will get there eventually <img src='http://blog.astrumfutura.com/wp-includes/images/smilies/icon_wink.gif' alt=';)' class='wp-smiley' /> ). It is released under a New BSD license.</p>
<h4>Example</h4>
<p>The <a href="http://github.com/padraic/mockery#readme">README offers a good look</a> at some examples, and explains the API in a lot of detail. If you are trying to figure something out, the README undoubtedly has a section for it. Here&#8217;s an API example (assuming Mockery namespace used as MK). We&#8217;re capturing an interaction where we login into a bookmarking service, check for the existance of a &#8220;php&#8221; tagged bookmark, add three more bookmarks and then recheck if a &#8220;php&#8221; tag exists (twice for fun). We&#8217;re mocking the service since we don&#8217;t actually want to mess with a real account! Following the description closely&#8230;</p>
<p>[geshi lang=php]$service = \MK::mock(&#8216;MyService&#8217;);<br />
$service->shouldReceive(&#8216;login&#8217;)->with(&#8216;user&#8217;, &#8216;pass&#8217;)->once()->andReturn(true);<br />
$service->shouldReceive(&#8216;hasBookmarksTagged&#8217;)->with(&#8216;php&#8217;)->once()->andReturn(false);<br />
$service->shouldReceive(&#8216;addBookmark&#8217;)->with(&#8216;/^http:/&#8217;, \MK::type(&#8216;string&#8217;))->times(3)->andReturn(true);<br />
$service->shouldReceive(&#8216;hasBookmarksTagged&#8217;)->with(&#8216;php&#8217;)->twice()->andReturn(true);[/geshi]</p>
<p>The example uses some of the basic parts of Mockery to describe some interaction with a mocked web service class (obviously<br />
also stubbing the web service&#8217;s responses in terms of booleans). The setup is straightforward, easy to follow, and there&#8217;s zero<br />
misinterpretations possible. Our description was likewise simple and uncomplicated. The third line just shows two argument matchers at work, a default regex (intrepreted from any string argument set so long as any eventual string comparison fails and it&#8217;s a valid regex) and a Type matcher set to match any valid string.</p>
<p>To put this into some perspective, here&#8217;s an equivalent attempt using PHPUnit in a similar order of thought (excerpt from a test).</p>
<p>[geshi lang=php]$service = $this->getMock(&#8216;MyService&#8217;);<br />
$service->expects($this->once())->method(&#8216;login&#8217;)->with(&#8216;user&#8217;, &#8216;pass&#8217;)->will($this->returnValue(true));<br />
$service->expects($this->once())->method(&#8216;hasBookmarksTagged&#8217;)->with(&#8216;php&#8217;)->will($this->returnValue(false));<br />
$service->expects($this->exactly(3))->method(&#8216;addBookmark&#8217;)<br />
    ->with($this->matchesRegularExpression(&#8216;/^http:/&#8217;), $this->isType(&#8216;string&#8217;))<br />
    ->will($this->returnValue(true));<br />
$service->expects($this->exactly(2))->method(&#8216;hasBookmarksTagged&#8217;)->with(&#8216;php&#8217;)->will($this->returnValue(true));[/geshi]</p>
<p>Besides the differences in API, there are others. If MyService is just intended as a fake unimplemented object (the class doesn&#8217;t exist), Mockery carries on and just uses a generic Mock instance without error. PHPUnit will throw an exception, however, stating that login() is not a valid method. If we assume the class is real, but missing some methods, the same thing happens and PHPUnit complains about missing methods. Eventually, you&#8217;ll get the idea to implement the dependent class&#8230; If we add all the relevant methods (say, we mock an interface with all methods declared), PHPUnit STILL fails. This time complaining that hasBookmarksTagged() was expected only once. This occurs because PHPUnit has no capacity for stacking later expectations, and so, it ignores the second (and any later) ones. We can fix that by merging both into a single expectation using:</p>
<p>[geshi lang=php]$service = $this->getMock(&#8216;MyService&#8217;);<br />
$service->expects($this->once())->method(&#8216;login&#8217;)->with(&#8216;user&#8217;, &#8216;pass&#8217;)->will($this->returnValue(true));<br />
$service->expects($this->exactly(3))->method(&#8216;hasBookmarksTagged&#8217;)->with(&#8216;php&#8217;)<br />
    ->will($this->onConsecutiveCalls(false, true, true));<br />
$service->expects($this->exactly(3))->method(&#8216;addBookmark&#8217;)<br />
    ->with($this->matchesRegularExpression(&#8216;/^http:/&#8217;), $this->isType(&#8216;string&#8217;))<br />
    ->will($this->returnValue(true));[/geshi]</p>
<p>Using OnConsecutiveCalls() to create a return value queue, and merging the two stacked expectations, allows the PHPUnit variant to pass. Unlike Mockery, if there were ten hasBookmarksTagged() calls, you would need to add all ten return values (Mockery let&#8217;s you set the last return value to act infinitely). The merging simply demonstrates that complex class interactions across classes will fall victim to the need to constantly merge expectations until they are unreadable and explain little.</p>
<p>While your mileage may vary, Mockery just doesn&#8217;t need reworking, deep thought or extra work. Just state what you want your Mock Object to do in plain unconfused English according to your natural thought order! If nothing else, it helps make the expected interaction obvious which makes your tests more readable and explicit.</p>
<h4>Feedback</h4>
<p>Any issues can be reported via our Github hosted issue tracker. If you wish to discuss Mockery in more detail, you&#8217;re welcome to join the mailing list at <a href="http://groups.google.com/group/phpmockery">http://groups.google.com/group/phpmockery</a>.</p>
";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:36:"http://wellformedweb.org/CommentAPI/";a:1:{s:10:"commentRss";a:1:{i:0;a:5:{s:4:"data";s:89:"http://blog.astrumfutura.com/2010/05/mockery-0-6-released-php-mock-object-framework/feed/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:38:"http://purl.org/rss/1.0/modules/slash/";a:1:{s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:1:"8";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}}}i:9;a:6:{s:4:"data";s:68:"
		
		
		
		
		
				
		
		
		
		
		
		
		
		
		

		
		
			
			
		
		";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";s:5:"child";a:5:{s:0:"";a:7:{s:5:"title";a:1:{i:0;a:5:{s:4:"data";s:40:"Mockery: From Mock Objects to Test Spies";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"link";a:1:{i:0;a:5:{s:4:"data";s:77:"http://blog.astrumfutura.com/2010/05/mockery-from-mock-objects-to-test-spies/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:86:"http://blog.astrumfutura.com/2010/05/mockery-from-mock-objects-to-test-spies/#comments";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:7:"pubDate";a:1:{i:0;a:5:{s:4:"data";s:31:"Sun, 23 May 2010 15:01:38 +0000";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:8:"category";a:10:{i:0;a:5:{s:4:"data";s:11:"PHP General";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:1;a:5:{s:4:"data";s:12:"PHP Security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:2;a:5:{s:4:"data";s:14:"Zend Framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:3;a:5:{s:4:"data";s:12:"mock objects";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:4;a:5:{s:4:"data";s:7:"mockery";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:5;a:5:{s:4:"data";s:11:"php general";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:6;a:5:{s:4:"data";s:12:"php security";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:7;a:5:{s:4:"data";s:8:"test spy";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:8;a:5:{s:4:"data";s:12:"unit testing";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:9;a:5:{s:4:"data";s:14:"zend framework";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:4:"guid";a:1:{i:0;a:5:{s:4:"data";s:35:"http://blog.astrumfutura.com/?p=417";s:7:"attribs";a:1:{s:0:"";a:1:{s:11:"isPermaLink";s:5:"false";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:11:"description";a:1:{i:0;a:5:{s:4:"data";s:350:"With next week seeing the formal release of Mockery 0.6 which is currently fermenting on Github at http://github.com/padraic/mockery, I&#8217;m already looking forward to next piece of the puzzle arriving with 0.7. Mockery is an opportunity to being something new and fresh to the PHP mock objects environment beyond a far neater flexible API. If you";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:32:"http://purl.org/dc/elements/1.1/";a:1:{s:7:"creator";a:1:{i:0;a:5:{s:4:"data";s:14:"Pádraic Brady";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:40:"http://purl.org/rss/1.0/modules/content/";a:1:{s:7:"encoded";a:1:{i:0;a:5:{s:4:"data";s:7002:"<div class="tweetmeme_button" style="float: right; margin-left: 10px;">
			<a href="http://api.tweetmeme.com/share?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F05%2Fmockery-from-mock-objects-to-test-spies%2F"><br />
				<img src="http://api.tweetmeme.com/imagebutton.gif?url=http%3A%2F%2Fblog.astrumfutura.com%2F2010%2F05%2Fmockery-from-mock-objects-to-test-spies%2F&amp;source=padraicb&amp;style=normal&amp;service=bit.ly&amp;service_api=padraic%3AR_94101570b7e190f3de921bc15bb9438d&amp;hashtags=mock+objects,mockery,php+general,php+security,test+spy,unit+testing,zend+framework&amp;o=http%3A%2F%2Fblog.astrumfutura.com%2Ffeeds%2Findex.rss2&amp;b=2" height="61" width="50" /><br />
			</a>
		</div>
<p>With next week seeing the formal release of Mockery 0.6 which is currently fermenting on Github at <a href="http://github.com/padraic/mockery">http://github.com/padraic/mockery</a>, I&#8217;m already looking forward to next piece of the puzzle arriving with 0.7. Mockery is an opportunity to being something new and fresh to the PHP mock objects environment beyond a far neater flexible API.</p>
<p>If you follow the test double debate in other languages there are two popular concepts making their presence felt. The first is that the over-specified definitions of test doubles (we have dummy objects, test stubs, mock objects, test spies and fake objects) do more harm than good since in reality we never really distinguish (nor care to) between most of them. In most cases we just sort of wing it, using our own concepts and intent to create test doubles which do what we want with little thought as to the kind of test double we&#8217;re creating. In the end, the definitions all merge together into a spectrum of possible behaviours we add as and if needed.</p>
<p>The second is that we&#8217;re seeing a lot more attention over whether Mock Objects are the best way to do things. Nobody doubts they have the right idea with Mock Objects, but the upfront setting of expectations may come across as unintuitive. A typical test begins with exercising code, and thereafter we typically make assertions on the behaviour (whether it be a resulting state change or an object interaction). Mock Objects reverse that &#8211; we expect first, and then we exercise the code.</p>
<p>With the future (before end of June) 0.7 release, Mockery will offer an alternative approach to the traditional Expect-Exercise-Verify cycle called the Test Spy. 0.6 already offers a measure of that capability through its ability to record interactions, though recording is completely automated and geared primarily towards comparing two sets of source code which should behave identically (e.g. during refactoring). The new Test Spy implementation will be API driven, using a similar form to Mockery&#8217;s existing Mock Object approach.</p>
<p>Why Test Spies?</p>
<p>Using Test Spies returns to the test based approach of exercising code first, and then making assertions. There&#8217;s a reason why this cyclical approach is used in unit testing. It&#8217;s easy to understand and makes sense from the start. Applying it to what we do with Mock Objects can make using Test Doubles in general easier to learn and teach. It may also remove barriers to entry for those who simply never understood Mock Objects or loathed their expectation setup.  Test Spies also operate on a selective basis &#8211; where Mock Objects require upfront expectations to define how they will behave, Test Spies just do what you need them to and then allow selective assertions afterwards (i.e. you only need to test what you want to test).</p>
<p>The difference, once you see the code, is very subtle. Not unusually for testing practices, subtle differences in approach rely on the YMMV yardstick. Some people prefer the upfront expectation setting, others find the after-use assertion approach easier to understand or as more applicable to their thinking.</p>
<p>By supporting both approaches as equal citizens, Mockery once again lets go of the proverbial rope around your neck tied there by Java traditions. You&#8217;ll be free to go with whatever approach you find yourself preferring. Better, they can both co-exist in relative peace since they are drawn from the same framework and both share nearly all of the exact same API elements, with the exact same meaning. Whether you prefer Mock Objects or Test Spies (both equally are capable of being used as Test Stubs), they are both equally understandable by anyone using Mockery.</p>
<p>As a means of showing the differences, here are two test cases. The first is written using the Mock Object terminology, the second using the Test Spy terminology &#8211; each actually achieves the exact same goal.</p>
<p>[geshi lang=php]use \Mockery as M;</p>
<p>class StarshipTest extends PHPUnit_Framework_TestCase<br />
{</p>
<p>    public function testEngagingWarpDrive()<br />
    {<br />
        $engineering = M::mock(&#8216;Engineering&#8217;);<br />
        $engineering->shouldReceive(&#8216;prepForWarpFactor&#8217;)->with(8)->once()->andReturn(true);<br />
        $engineering->shouldReceive(&#8216;engage&#8217;)->once();</p>
<p>        $starship = new Starship($engineering);<br />
        $starship->accelerateToWarp(8);<br />
    }</p>
<p>}[/geshi]</p>
<p>Or, using a Test Spy approach.</p>
<p>[geshi lang=php]use \Mockery as M;</p>
<p>class StarshipTest extends PHPUnit_Framework_TestCase<br />
{</p>
<p>    public function testEngagingWarpDrive()<br />
    {<br />
        $engineering = M::mock(&#8216;Engineering&#8217;);<br />
        $engineering->whenReceives(&#8216;prepForWarpFactor&#8217;)->thenReturn(true);</p>
<p>        $starship = new Starship($engineering);<br />
        $starship->accelerateToWarp(8);</p>
<p>        $engineering->assertReceived(&#8216;prepForWarpFactor&#8217;)->with(8)->once();<br />
        $engineering->assertReceived(&#8216;engage&#8217;)->once();<br />
    }</p>
<p>}[/geshi]</p>
<p>To demonstrate the selective assertion approach, what if we just didn&#8217;t care about whether or not the engage() method was used? In that case, we could just drop it from the assertions altogether &#8211; never mentioning it in the test at all. In the Mock Object approach, we cannot do this &#8211; mocking means we must set all methods expected (otherwise the methods would not exist on the mock). We could even drop the assertion on prepForWarpFactor, although we still need to retain the stubbing of its return value (since it&#8217;s needed).</p>
<p>Supporting Test Spies and Mock Objects also has the other obvious benefit that you can switch modes effortlessly. There will always be cases where expectation setting is preferable over assertions and vice versa. Both have their uses even if you heavily prefer any one over the other.</p>
<p>Watch for the Mockery 0.6 release next week! I&#8217;ll follow through with Test Spies in 0.7 once I get the final API down (working on making it even shorter than our Mock Object API can achieve).</p>
";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:36:"http://wellformedweb.org/CommentAPI/";a:1:{s:10:"commentRss";a:1:{i:0;a:5:{s:4:"data";s:82:"http://blog.astrumfutura.com/2010/05/mockery-from-mock-objects-to-test-spies/feed/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:38:"http://purl.org/rss/1.0/modules/slash/";a:1:{s:8:"comments";a:1:{i:0;a:5:{s:4:"data";s:1:"5";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}}}}}s:27:"http://www.w3.org/2005/Atom";a:1:{s:4:"link";a:2:{i:0;a:5:{s:4:"data";s:0:"";s:7:"attribs";a:1:{s:0:"";a:3:{s:4:"href";s:34:"http://blog.astrumfutura.com/feed/";s:3:"rel";s:4:"self";s:4:"type";s:19:"application/rss+xml";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}i:1;a:5:{s:4:"data";s:0:"";s:7:"attribs";a:1:{s:0:"";a:2:{s:3:"rel";s:3:"hub";s:4:"href";s:31:"http://pubsubhubbub.appspot.com";}}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:44:"http://purl.org/rss/1.0/modules/syndication/";a:2:{s:12:"updatePeriod";a:1:{i:0;a:5:{s:4:"data";s:6:"hourly";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}s:15:"updateFrequency";a:1:{i:0;a:5:{s:4:"data";s:1:"1";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}s:52:"http://backend.userland.com/creativeCommonsRssModule";a:1:{s:7:"license";a:1:{i:0;a:5:{s:4:"data";s:49:"http://creativecommons.org/licenses/by-nc-nd/3.0/";s:7:"attribs";a:0:{}s:8:"xml_base";s:0:"";s:17:"xml_base_explicit";b:0;s:8:"xml_lang";s:0:"";}}}}}}}}}}}}s:4:"type";i:128;s:7:"headers";a:14:{s:4:"date";s:29:"Sat, 19 Feb 2011 00:43:10 GMT";s:6:"server";s:22:"Apache/2.2.14 (Ubuntu)";s:12:"x-powered-by";s:20:"PHP/5.3.2-1ubuntu4.7";s:10:"set-cookie";s:44:"PHPSESSID=tgsarij9clqg2v6l18to94tis7; path=/";s:7:"expires";s:29:"Thu, 19 Nov 1981 08:52:00 GMT";s:13:"cache-control";s:62:"no-store, no-cache, must-revalidate, post-check=0, pre-check=0";s:6:"pragma";s:8:"no-cache";s:10:"x-pingback";s:39:"http://blog.astrumfutura.com/xmlrpc.php";s:13:"last-modified";s:29:"Wed, 20 Oct 2010 20:57:26 GMT";s:4:"etag";s:32:"404557fb35c791de1ed5c60514806e5b";s:4:"vary";s:15:"Accept-Encoding";s:16:"content-encoding";s:4:"gzip";s:14:"content-length";s:5:"41064";s:12:"content-type";s:23:"text/xml; charset=UTF-8";}s:5:"build";s:14:"20110128231735";}